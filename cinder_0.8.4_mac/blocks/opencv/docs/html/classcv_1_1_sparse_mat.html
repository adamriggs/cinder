<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacecv.html">cv</a>      </li>
      <li class="navelem"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cv::SparseMat Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sparse matrix class.  
 <a href="classcv_1_1_sparse_mat.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_8hpp_source.html">core.hpp</a>&gt;</code></p>

<p>Inherited by <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

<p><a href="classcv_1_1_sparse_mat-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">Hdr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the sparse matrix header  <a href="structcv_1_1_sparse_mat_1_1_hdr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse matrix node - element of a hash table  <a href="structcv_1_1_sparse_mat_1_1_node.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7de4c57f754bb368c85152c1909cb65b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classcv_1_1_sparse_mat.html#a7de4c57f754bb368c85152c1909cb65ba14d02d4adbcb5fa71d1922ceda241e8a">MAGIC_VAL</a> = 0x42FD0000, 
<a class="el" href="classcv_1_1_sparse_mat.html#a7de4c57f754bb368c85152c1909cb65babe1aff4cd2b540afd5a3f4ffca3bd9a2">MAX_DIM</a> = CV_MAX_DIM, 
<a class="el" href="classcv_1_1_sparse_mat.html#a7de4c57f754bb368c85152c1909cb65ba28ca477c8ed1afabd0da753827149eeb">HASH_SCALE</a> = 0x5bd1e995, 
<a class="el" href="classcv_1_1_sparse_mat.html#a7de4c57f754bb368c85152c1909cb65ba79cfd2c6ddc2c192623e8426429d27d1">HASH_BIT</a> = 0x80000000
 }</td></tr>
<tr class="memitem:aa766accd9ac415bea90019010f58cac6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aa766accd9ac415bea90019010f58cac6">iterator</a></td></tr>
<tr class="memitem:a4f7803d5c41eef808081903167d3a263"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a4f7803d5c41eef808081903167d3a263">const_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b5f1214a43144122b158c354a93e338"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">SparseMat</a> ()</td></tr>
<tr class="memdesc:a9b5f1214a43144122b158c354a93e338"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#a9b5f1214a43144122b158c354a93e338"></a><br/></td></tr>
<tr class="memitem:a62224fe4fbdc6134d80861a150e01b58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a62224fe4fbdc6134d80861a150e01b58">SparseMat</a> (int <a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">dims</a>, const int *_sizes, int _type)</td></tr>
<tr class="memdesc:a62224fe4fbdc6134d80861a150e01b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates matrix of the specified size and type  <a href="#a62224fe4fbdc6134d80861a150e01b58"></a><br/></td></tr>
<tr class="memitem:a753add6192d4355c04e6e3594ab97b49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a753add6192d4355c04e6e3594ab97b49">SparseMat</a> (const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m)</td></tr>
<tr class="memdesc:a753add6192d4355c04e6e3594ab97b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a753add6192d4355c04e6e3594ab97b49"></a><br/></td></tr>
<tr class="memitem:af9432a94bda00c7fd2103bcd57654d03"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af9432a94bda00c7fd2103bcd57654d03">SparseMat</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr class="memdesc:af9432a94bda00c7fd2103bcd57654d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts dense 2d matrix to the sparse form  <a href="#af9432a94bda00c7fd2103bcd57654d03"></a><br/></td></tr>
<tr class="memitem:a2d812e359959b424068743618ecd2e05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a2d812e359959b424068743618ecd2e05">SparseMat</a> (const <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a> *m)</td></tr>
<tr class="memdesc:a2d812e359959b424068743618ecd2e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts old-style sparse matrix to the new-style. All the data is copied  <a href="#a2d812e359959b424068743618ecd2e05"></a><br/></td></tr>
<tr class="memitem:a1903162ea8588b8dd0c4421824f8dd9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a1903162ea8588b8dd0c4421824f8dd9d">~SparseMat</a> ()</td></tr>
<tr class="memdesc:a1903162ea8588b8dd0c4421824f8dd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the destructor  <a href="#a1903162ea8588b8dd0c4421824f8dd9d"></a><br/></td></tr>
<tr class="memitem:ab80c24b3713add05c507ff56b3350ca2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ab80c24b3713add05c507ff56b3350ca2">operator=</a> (const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m)</td></tr>
<tr class="memdesc:ab80c24b3713add05c507ff56b3350ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator. This is O(1) operation, i.e. no data is copied  <a href="#ab80c24b3713add05c507ff56b3350ca2"></a><br/></td></tr>
<tr class="memitem:a0ddfb53cd5f03f1b262d0f3c7b951f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a0ddfb53cd5f03f1b262d0f3c7b951f6d">operator=</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr class="memdesc:a0ddfb53cd5f03f1b262d0f3c7b951f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to the corresponding constructor  <a href="#a0ddfb53cd5f03f1b262d0f3c7b951f6d"></a><br/></td></tr>
<tr class="memitem:a4c990be3ea562ab9f40c40edaf773a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a4c990be3ea562ab9f40c40edaf773a5d">clone</a> () const </td></tr>
<tr class="memdesc:a4c990be3ea562ab9f40c40edaf773a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates full copy of the matrix  <a href="#a4c990be3ea562ab9f40c40edaf773a5d"></a><br/></td></tr>
<tr class="memitem:a93c268b7c58435d8ecc3577f439283ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a93c268b7c58435d8ecc3577f439283ee">copyTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m) const </td></tr>
<tr class="memdesc:a93c268b7c58435d8ecc3577f439283ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies all the data to the destination matrix. All the previous content of m is erased  <a href="#a93c268b7c58435d8ecc3577f439283ee"></a><br/></td></tr>
<tr class="memitem:adb6344cbc400408f30300dd1a0112da9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#adb6344cbc400408f30300dd1a0112da9">copyTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m) const </td></tr>
<tr class="memdesc:adb6344cbc400408f30300dd1a0112da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to dense matrix.  <a href="#adb6344cbc400408f30300dd1a0112da9"></a><br/></td></tr>
<tr class="memitem:a6ad5f495abf7eedede64afa7203b6b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6ad5f495abf7eedede64afa7203b6b78">convertTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m, int rtype, double <a class="el" href="legacy_8hpp.html#a95fc8341ca418bc06b36160632af6d47">alpha</a>=1) const </td></tr>
<tr class="memdesc:a6ad5f495abf7eedede64afa7203b6b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type  <a href="#a6ad5f495abf7eedede64afa7203b6b78"></a><br/></td></tr>
<tr class="memitem:ac631bd31ae1ce1944ba6775f2ce121be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac631bd31ae1ce1944ba6775f2ce121be">convertTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, int rtype, double <a class="el" href="legacy_8hpp.html#a95fc8341ca418bc06b36160632af6d47">alpha</a>=1, double <a class="el" href="legacy_8hpp.html#af8b31eb489dfbd87f3b1a1925cca3589">beta</a>=0) const </td></tr>
<tr class="memdesc:ac631bd31ae1ce1944ba6775f2ce121be"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to dense n-dim matrix with optional type conversion and scaling.  <a href="#ac631bd31ae1ce1944ba6775f2ce121be"></a><br/></td></tr>
<tr class="memitem:a0dfa0e1a634f76787997a495dd4bdbf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a0dfa0e1a634f76787997a495dd4bdbf0">assignTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m, int <a class="el" href="classcv_1_1_sparse_mat.html#a2611b9eb569ba46ea7013f17c22bfbf8">type</a>=-1) const </td></tr>
<tr class="memitem:adf2713a5ec1fb025c9ff4014a53e68c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#adf2713a5ec1fb025c9ff4014a53e68c6">create</a> (int <a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">dims</a>, const int *_sizes, int _type)</td></tr>
<tr class="memdesc:adf2713a5ec1fb025c9ff4014a53e68c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">reallocates sparse matrix.  <a href="#adf2713a5ec1fb025c9ff4014a53e68c6"></a><br/></td></tr>
<tr class="memitem:a2fa705d84961513f6e0b0066ec245a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e">clear</a> ()</td></tr>
<tr class="memdesc:a2fa705d84961513f6e0b0066ec245a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets all the sparse matrix elements to 0, which means clearing the hash table.  <a href="#a2fa705d84961513f6e0b0066ec245a8e"></a><br/></td></tr>
<tr class="memitem:a8d1d03d3c19ccd8cd5653b3b7375bb68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a8d1d03d3c19ccd8cd5653b3b7375bb68">addref</a> ()</td></tr>
<tr class="memdesc:a8d1d03d3c19ccd8cd5653b3b7375bb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">manually increments the reference counter to the header.  <a href="#a8d1d03d3c19ccd8cd5653b3b7375bb68"></a><br/></td></tr>
<tr class="memitem:a3f4c162afd8cc809d23bd0fe9b38ead7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3f4c162afd8cc809d23bd0fe9b38ead7">release</a> ()</td></tr>
<tr class="memitem:a3b522e2f57e588c0f7cb4d3a3b69e8e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3b522e2f57e588c0f7cb4d3a3b69e8e4">operator CvSparseMat *</a> () const </td></tr>
<tr class="memdesc:a3b522e2f57e588c0f7cb4d3a3b69e8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to the old-style representation; all the elements are copied.  <a href="#a3b522e2f57e588c0f7cb4d3a3b69e8e4"></a><br/></td></tr>
<tr class="memitem:a00f7940230adaaad7bc231016c646f1e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a00f7940230adaaad7bc231016c646f1e">elemSize</a> () const </td></tr>
<tr class="memdesc:a00f7940230adaaad7bc231016c646f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of each element in bytes (not including the overhead - the space occupied by <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html" title="sparse matrix node - element of a hash table">SparseMat::Node</a> elements)  <a href="#a00f7940230adaaad7bc231016c646f1e"></a><br/></td></tr>
<tr class="memitem:abe50d2428ea7bdc8fb74b48248036dc6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#abe50d2428ea7bdc8fb74b48248036dc6">elemSize1</a> () const </td></tr>
<tr class="memdesc:abe50d2428ea7bdc8fb74b48248036dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classcv_1_1_sparse_mat.html#a00f7940230adaaad7bc231016c646f1e" title="returns the size of each element in bytes (not including the overhead - the space occupied by SparseM...">elemSize()</a>/channels()  <a href="#abe50d2428ea7bdc8fb74b48248036dc6"></a><br/></td></tr>
<tr class="memitem:a2611b9eb569ba46ea7013f17c22bfbf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a2611b9eb569ba46ea7013f17c22bfbf8">type</a> () const </td></tr>
<tr class="memdesc:a2611b9eb569ba46ea7013f17c22bfbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns type of sparse matrix elements  <a href="#a2611b9eb569ba46ea7013f17c22bfbf8"></a><br/></td></tr>
<tr class="memitem:a693e497e5384674c269d415e845dd74a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a693e497e5384674c269d415e845dd74a">depth</a> () const </td></tr>
<tr class="memdesc:a693e497e5384674c269d415e845dd74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the depth of sparse matrix elements  <a href="#a693e497e5384674c269d415e845dd74a"></a><br/></td></tr>
<tr class="memitem:ad0c723bd46ceee0a6c88299fffa7a8b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad0c723bd46ceee0a6c88299fffa7a8b9">channels</a> () const </td></tr>
<tr class="memdesc:ad0c723bd46ceee0a6c88299fffa7a8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of channels  <a href="#ad0c723bd46ceee0a6c88299fffa7a8b9"></a><br/></td></tr>
<tr class="memitem:a8257efe5b5a93b90da0daf89171012df"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a8257efe5b5a93b90da0daf89171012df">size</a> () const </td></tr>
<tr class="memdesc:a8257efe5b5a93b90da0daf89171012df"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the array of sizes, or NULL if the matrix is not allocated  <a href="#a8257efe5b5a93b90da0daf89171012df"></a><br/></td></tr>
<tr class="memitem:af4bd8427b4673af70a6eeeb4559c419a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af4bd8427b4673af70a6eeeb4559c419a">size</a> (int i) const </td></tr>
<tr class="memdesc:af4bd8427b4673af70a6eeeb4559c419a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of i-th matrix dimension (or 0)  <a href="#af4bd8427b4673af70a6eeeb4559c419a"></a><br/></td></tr>
<tr class="memitem:a3ff274ef6039cd6db69f156dcbb4ab93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">dims</a> () const </td></tr>
<tr class="memdesc:a3ff274ef6039cd6db69f156dcbb4ab93"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the matrix dimensionality  <a href="#a3ff274ef6039cd6db69f156dcbb4ab93"></a><br/></td></tr>
<tr class="memitem:ab89d7c867e110b49316c6eb2d5d69f85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ab89d7c867e110b49316c6eb2d5d69f85">nzcount</a> () const </td></tr>
<tr class="memdesc:ab89d7c867e110b49316c6eb2d5d69f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of non-zero elements (=the number of hash table nodes)  <a href="#ab89d7c867e110b49316c6eb2d5d69f85"></a><br/></td></tr>
<tr class="memitem:ac28efc048ec9585e0febb830d203fe8b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">hash</a> (int i0) const </td></tr>
<tr class="memdesc:ac28efc048ec9585e0febb830d203fe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (1D case)  <a href="#ac28efc048ec9585e0febb830d203fe8b"></a><br/></td></tr>
<tr class="memitem:aa6f502942ecfb926d2a8879bd9dbc8a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aa6f502942ecfb926d2a8879bd9dbc8a9">hash</a> (int i0, int i1) const </td></tr>
<tr class="memdesc:aa6f502942ecfb926d2a8879bd9dbc8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (2D case)  <a href="#aa6f502942ecfb926d2a8879bd9dbc8a9"></a><br/></td></tr>
<tr class="memitem:aba7d44641efd3c8de7b2bfbff023b384"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aba7d44641efd3c8de7b2bfbff023b384">hash</a> (int i0, int i1, int i2) const </td></tr>
<tr class="memdesc:aba7d44641efd3c8de7b2bfbff023b384"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (3D case)  <a href="#aba7d44641efd3c8de7b2bfbff023b384"></a><br/></td></tr>
<tr class="memitem:ac83549f5a561022195e387022ee9b06c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac83549f5a561022195e387022ee9b06c">hash</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>) const </td></tr>
<tr class="memdesc:ac83549f5a561022195e387022ee9b06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (nD case)  <a href="#ac83549f5a561022195e387022ee9b06c"></a><br/></td></tr>
<tr class="memitem:af5f0a657ed8469a56236df5082bbb78e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af5f0a657ed8469a56236df5082bbb78e">end</a> ()</td></tr>
<tr class="memdesc:af5f0a657ed8469a56236df5082bbb78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the sparse matrix iterator pointing to the element following the last sparse matrix element  <a href="#af5f0a657ed8469a56236df5082bbb78e"></a><br/></td></tr>
<tr class="memitem:a1d3e2e9de51dfa3a519e9489876eee7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a1d3e2e9de51dfa3a519e9489876eee7b">end</a> () const </td></tr>
<tr class="memdesc:a1d3e2e9de51dfa3a519e9489876eee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the read-only sparse matrix iterator at the matrix end  <a href="#a1d3e2e9de51dfa3a519e9489876eee7b"></a><br/></td></tr>
<tr class="memitem:a4fe2ca854bcafa54cb371146523c7e36"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a4fe2ca854bcafa54cb371146523c7e36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a4fe2ca854bcafa54cb371146523c7e36">end</a> ()</td></tr>
<tr class="memdesc:a4fe2ca854bcafa54cb371146523c7e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the typed sparse matrix iterator at the matrix end  <a href="#a4fe2ca854bcafa54cb371146523c7e36"></a><br/></td></tr>
<tr class="memitem:a037118a6224726aad087e3e9258f57b1"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a037118a6224726aad087e3e9258f57b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a037118a6224726aad087e3e9258f57b1">end</a> () const </td></tr>
<tr class="memdesc:a037118a6224726aad087e3e9258f57b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the typed read-only sparse matrix iterator at the matrix end  <a href="#a037118a6224726aad087e3e9258f57b1"></a><br/></td></tr>
<tr class="memitem:afe08b740792d6e7f31706616685b70f9"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:afe08b740792d6e7f31706616685b70f9"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#afe08b740792d6e7f31706616685b70f9">value</a> (<a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *<a class="el" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:afe08b740792d6e7f31706616685b70f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value stored in the sparse martix node  <a href="#afe08b740792d6e7f31706616685b70f9"></a><br/></td></tr>
<tr class="memitem:a18d86c436d847195806cf3c1dd07751f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a18d86c436d847195806cf3c1dd07751f"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a18d86c436d847195806cf3c1dd07751f">value</a> (const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *<a class="el" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const </td></tr>
<tr class="memdesc:a18d86c436d847195806cf3c1dd07751f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value stored in the sparse martix node  <a href="#a18d86c436d847195806cf3c1dd07751f"></a><br/></td></tr>
<tr class="memitem:a6255da02af3f6d71c2d4dfcc9b94a524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6255da02af3f6d71c2d4dfcc9b94a524">node</a> (size_t nidx)</td></tr>
<tr class="memitem:ac384b30f4c291e6a2526c69dc3de0c98"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac384b30f4c291e6a2526c69dc3de0c98">node</a> (size_t nidx) const </td></tr>
<tr class="memitem:acfbf3c27ab6d5f90e4d37b1654f90f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#acfbf3c27ab6d5f90e4d37b1654f90f0a">newNode</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t hashval)</td></tr>
<tr class="memitem:a5adcb69ee679da35f74ea3a78594a692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a5adcb69ee679da35f74ea3a78594a692">removeNode</a> (size_t hidx, size_t nidx, size_t previdx)</td></tr>
<tr class="memitem:af86523883daef3f618a7ec38fe049edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af86523883daef3f618a7ec38fe049edc">resizeHashTab</a> (size_t newsize)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a810b96cf23e3cc816e7f99473b81b513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">ptr</a> (int i0, bool createMissing, size_t *hashval=0)</td></tr>
<tr class="memdesc:a810b96cf23e3cc816e7f99473b81b513"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case.  <a href="#a810b96cf23e3cc816e7f99473b81b513"></a><br/></td></tr>
<tr class="memitem:a14e7bb6106e6b4608ddbbc394bbf585e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a14e7bb6106e6b4608ddbbc394bbf585e">ptr</a> (int i0, int i1, bool createMissing, size_t *hashval=0)</td></tr>
<tr class="memdesc:a14e7bb6106e6b4608ddbbc394bbf585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (2D case)  <a href="#a14e7bb6106e6b4608ddbbc394bbf585e"></a><br/></td></tr>
<tr class="memitem:afa0e9b6331a781f1d746e77582bee8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#afa0e9b6331a781f1d746e77582bee8a8">ptr</a> (int i0, int i1, int i2, bool createMissing, size_t *hashval=0)</td></tr>
<tr class="memdesc:afa0e9b6331a781f1d746e77582bee8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (3D case)  <a href="#afa0e9b6331a781f1d746e77582bee8a8"></a><br/></td></tr>
<tr class="memitem:a5425bac965f62767f50c7e68a7c452a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a5425bac965f62767f50c7e68a7c452a0">ptr</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, bool createMissing, size_t *hashval=0)</td></tr>
<tr class="memdesc:a5425bac965f62767f50c7e68a7c452a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (nD case)  <a href="#a5425bac965f62767f50c7e68a7c452a0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a925b05f8347aaf82ec037fd823bb2a0e"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a925b05f8347aaf82ec037fd823bb2a0e"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a925b05f8347aaf82ec037fd823bb2a0e">ref</a> (int i0, size_t *hashval=0)</td></tr>
<tr class="memdesc:a925b05f8347aaf82ec037fd823bb2a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return read-write reference to the specified sparse matrix element.  <a href="#a925b05f8347aaf82ec037fd823bb2a0e"></a><br/></td></tr>
<tr class="memitem:aa027e36635c11e7b59fbf1f64a0d4798"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aa027e36635c11e7b59fbf1f64a0d4798"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aa027e36635c11e7b59fbf1f64a0d4798">ref</a> (int i0, int i1, size_t *hashval=0)</td></tr>
<tr class="memdesc:aa027e36635c11e7b59fbf1f64a0d4798"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to the specified element (2D case)  <a href="#aa027e36635c11e7b59fbf1f64a0d4798"></a><br/></td></tr>
<tr class="memitem:a533ec9897d2d9d1a151d07a05cced109"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a533ec9897d2d9d1a151d07a05cced109"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a533ec9897d2d9d1a151d07a05cced109">ref</a> (int i0, int i1, int i2, size_t *hashval=0)</td></tr>
<tr class="memdesc:a533ec9897d2d9d1a151d07a05cced109"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to the specified element (3D case)  <a href="#a533ec9897d2d9d1a151d07a05cced109"></a><br/></td></tr>
<tr class="memitem:a4e7feaec46317e5dae1d2de5c3aa9c18"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a4e7feaec46317e5dae1d2de5c3aa9c18"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a4e7feaec46317e5dae1d2de5c3aa9c18">ref</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0)</td></tr>
<tr class="memdesc:a4e7feaec46317e5dae1d2de5c3aa9c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns reference to the specified element (nD case)  <a href="#a4e7feaec46317e5dae1d2de5c3aa9c18"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a25af0320f3323181aeb16eae3a2cca55"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a25af0320f3323181aeb16eae3a2cca55"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">value</a> (int i0, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a25af0320f3323181aeb16eae3a2cca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">return value of the specified sparse matrix element.  <a href="#a25af0320f3323181aeb16eae3a2cca55"></a><br/></td></tr>
<tr class="memitem:a0d254b1881f2a92080c34590034e48bd"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a0d254b1881f2a92080c34590034e48bd"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a0d254b1881f2a92080c34590034e48bd">value</a> (int i0, int i1, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a0d254b1881f2a92080c34590034e48bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (2D case)  <a href="#a0d254b1881f2a92080c34590034e48bd"></a><br/></td></tr>
<tr class="memitem:a288c58847a9cc310940f0f76f3dfce53"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a288c58847a9cc310940f0f76f3dfce53"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a288c58847a9cc310940f0f76f3dfce53">value</a> (int i0, int i1, int i2, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a288c58847a9cc310940f0f76f3dfce53"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (3D case)  <a href="#a288c58847a9cc310940f0f76f3dfce53"></a><br/></td></tr>
<tr class="memitem:a948563f1181b81c52b7a600538fa9657"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a948563f1181b81c52b7a600538fa9657"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a948563f1181b81c52b7a600538fa9657">value</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a948563f1181b81c52b7a600538fa9657"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (nD case)  <a href="#a948563f1181b81c52b7a600538fa9657"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a46196f5a4b345c43a6ee344d4daee171"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a46196f5a4b345c43a6ee344d4daee171"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">find</a> (int i0, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a46196f5a4b345c43a6ee344d4daee171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the specified sparse matrix element if it exists.  <a href="#a46196f5a4b345c43a6ee344d4daee171"></a><br/></td></tr>
<tr class="memitem:af5166def1d0ee208e61c13194d736c13"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af5166def1d0ee208e61c13194d736c13"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af5166def1d0ee208e61c13194d736c13">find</a> (int i0, int i1, size_t *hashval=0) const </td></tr>
<tr class="memdesc:af5166def1d0ee208e61c13194d736c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (2D case)  <a href="#af5166def1d0ee208e61c13194d736c13"></a><br/></td></tr>
<tr class="memitem:a76f091d90c610bc7c62404a5115fdd2d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a76f091d90c610bc7c62404a5115fdd2d"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a76f091d90c610bc7c62404a5115fdd2d">find</a> (int i0, int i1, int i2, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a76f091d90c610bc7c62404a5115fdd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (3D case)  <a href="#a76f091d90c610bc7c62404a5115fdd2d"></a><br/></td></tr>
<tr class="memitem:a01119d63e21697f1691b16cc1a00628a"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a01119d63e21697f1691b16cc1a00628a"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a01119d63e21697f1691b16cc1a00628a">find</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a01119d63e21697f1691b16cc1a00628a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (nD case)  <a href="#a01119d63e21697f1691b16cc1a00628a"></a><br/></td></tr>
<tr class="memitem:ad4ff041a2a3771613847b94c761ab1f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">erase</a> (int i0, int i1, size_t *hashval=0)</td></tr>
<tr class="memdesc:ad4ff041a2a3771613847b94c761ab1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (2D case)  <a href="#ad4ff041a2a3771613847b94c761ab1f4"></a><br/></td></tr>
<tr class="memitem:ab00d2c0c7bff3c631d1ac43fe1be45cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ab00d2c0c7bff3c631d1ac43fe1be45cd">erase</a> (int i0, int i1, int i2, size_t *hashval=0)</td></tr>
<tr class="memdesc:ab00d2c0c7bff3c631d1ac43fe1be45cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (3D case)  <a href="#ab00d2c0c7bff3c631d1ac43fe1be45cd"></a><br/></td></tr>
<tr class="memitem:a6f64485a3f47ba79847a3fdf349b9943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6f64485a3f47ba79847a3fdf349b9943">erase</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0)</td></tr>
<tr class="memdesc:a6f64485a3f47ba79847a3fdf349b9943"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (nD case)  <a href="#a6f64485a3f47ba79847a3fdf349b9943"></a><br/></td></tr>
<tr class="memitem:a45125aae0952d6b9777be600a8955a06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a45125aae0952d6b9777be600a8955a06">begin</a> ()</td></tr>
<tr class="memdesc:a45125aae0952d6b9777be600a8955a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the sparse matrix iterator pointing to the first sparse matrix element  <a href="#a45125aae0952d6b9777be600a8955a06"></a><br/></td></tr>
<tr class="memitem:af371f2cb6952b62ec7ad3b82538d9363"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af371f2cb6952b62ec7ad3b82538d9363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af371f2cb6952b62ec7ad3b82538d9363">begin</a> ()</td></tr>
<tr class="memdesc:af371f2cb6952b62ec7ad3b82538d9363"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the sparse matrix iterator at the matrix beginning  <a href="#af371f2cb6952b62ec7ad3b82538d9363"></a><br/></td></tr>
<tr class="memitem:ae70ca8ec2bf3945f832870ab7296c536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ae70ca8ec2bf3945f832870ab7296c536">begin</a> () const </td></tr>
<tr class="memdesc:ae70ca8ec2bf3945f832870ab7296c536"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the read-only sparse matrix iterator at the matrix beginning  <a href="#ae70ca8ec2bf3945f832870ab7296c536"></a><br/></td></tr>
<tr class="memitem:a2d1f52049dc822a75abf2f1d956e2b48"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a2d1f52049dc822a75abf2f1d956e2b48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a2d1f52049dc822a75abf2f1d956e2b48">begin</a> () const </td></tr>
<tr class="memdesc:a2d1f52049dc822a75abf2f1d956e2b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the read-only sparse matrix iterator at the matrix beginning  <a href="#a2d1f52049dc822a75abf2f1d956e2b48"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad5f261bc8c1330e4e516684861410cd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad5f261bc8c1330e4e516684861410cd2">flags</a></td></tr>
<tr class="memitem:a3741ff43acd46b31aace23dee092d85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">Hdr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3741ff43acd46b31aace23dee092d85a">hdr</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Sparse matrix class. </p>
<p>The class represents multi-dimensional sparse numerical arrays. Such a sparse array can store elements of any type that <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">cv::Mat</a> is able to store. "Sparse" means that only non-zero elements are stored (though, as a result of some operations on a sparse matrix, some of its stored elements can actually become 0. It's user responsibility to detect such elements and delete them using <a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4" title="erases the specified element (2D case)">cv::SparseMat::erase()</a>. The non-zero elements are stored in a hash table that grows when it's filled enough, so that the search time remains O(1) in average. Elements can be accessed using the following methods:</p>
<ol>
<li>
<p class="startli">Query operations: <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513" title="specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case.">cv::SparseMat::ptr()</a> and the higher-level <a class="el" href="classcv_1_1_sparse_mat.html#a925b05f8347aaf82ec037fd823bb2a0e" title="return read-write reference to the specified sparse matrix element.">cv::SparseMat::ref()</a>, <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55" title="return value of the specified sparse matrix element.">cv::SparseMat::value()</a> and <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171" title="Return pointer to the specified sparse matrix element if it exists.">cv::SparseMat::find</a>, for example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93" title="returns the matrix dimensionality">dims</a> = 5;
 <span class="keywordtype">int</span> size[] = {10, 10, 10, 10, 10};
 <a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338" title="default constructor">SparseMat</a> sparse_mat(dims, size, CV_32F);
 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 1000; i++)
 {
     <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>[<a class="code" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93" title="returns the matrix dimensionality">dims</a>];
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93" title="returns the matrix dimensionality">dims</a>; k++)
        idx[k] = rand()%sparse_mat.size(k);
     sparse_mat.ref&lt;<span class="keywordtype">float</span>&gt;(<a class="code" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>) += 1.f;
 }
</pre></div><p class="endli"></p>
</li>
<li>
<p class="startli">Sparse matrix iterators. Like <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">cv::Mat</a> iterators and unlike <a class="el" href="classcv_1_1_mat.html" title="The n-dimensional matrix class.">cv::Mat</a> iterators, the sparse matrix iterators are STL-style, that is, the iteration is done as following: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// prints elements of a sparse floating-point matrix and the sum of elements.</span>
 SparseMatConstIterator_&lt;float&gt;
        it = sparse_mat.begin&lt;<span class="keywordtype">float</span>&gt;(),
        it_end = sparse_mat.end&lt;<span class="keywordtype">float</span>&gt;();
 <span class="keywordtype">double</span> s = 0;
 <span class="keywordtype">int</span> dims = sparse_mat.dims();
 <span class="keywordflow">for</span>(; it != it_end; ++it)
 {
     <span class="comment">// print element indices and the element value</span>
     <span class="keyword">const</span> Node* <a class="code" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> = it.node();
     printf(<span class="stringliteral">&quot;(&quot;</span>)
     for(<span class="keywordtype">int</span> i = 0; i &lt; dims; i++)
        printf(&quot;%3<a class="code" href="imgproc__c_8h.html#a6f364afbe132c4ecfea48bde1b0618ba">d</a>%<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>&quot;, n-&gt;idx[i], i &lt; dims-1 ? &#39;,&#39; : &#39;)&#39;);
     printf(&quot;: %f\n&quot;, *it);    
     s += *it;
 }
 printf(&quot;Element sum is %g\n&quot;, s);
</pre></div><p> If you run this loop, you will notice that elements are enumerated in no any logical order (lexicographical etc.), they come in the same order as they stored in the hash table, i.e. semi-randomly.</p>
<p>You may collect pointers to the nodes and sort them to get the proper ordering. Note, however, that pointers to the nodes may become invalid when you add more elements to the matrix; this is because of possible buffer reallocation.</p>
<p class="endli"></p>
</li>
<li>
A combination of the above 2 methods when you need to process 2 or more sparse matrices simultaneously, e.g. this is how you can compute unnormalized cross-correlation of the 2 floating-point sparse matrices: <div class="fragment"><pre class="fragment"> <span class="keywordtype">double</span> crossCorr(<span class="keyword">const</span> <a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338" title="default constructor">SparseMat</a>&amp; <a class="code" href="legacy_8hpp.html#a1031d0e0a97a340abfe0a6ab9e831045">a</a>, <span class="keyword">const</span> <a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338" title="default constructor">SparseMat</a>&amp; <a class="code" href="legacy_8hpp.html#ac04272e8ca865b8fba18d36edae9fd2a">b</a>)
 {
     <span class="keyword">const</span> <a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338" title="default constructor">SparseMat</a> *_a = &amp;<a class="code" href="legacy_8hpp.html#a1031d0e0a97a340abfe0a6ab9e831045">a</a>, *_b = &amp;<a class="code" href="legacy_8hpp.html#ac04272e8ca865b8fba18d36edae9fd2a">b</a>;
     <span class="comment">// if b contains less elements than a,</span>
     <span class="comment">// it&#39;s faster to iterate through b</span>
     <span class="keywordflow">if</span>(_a-&gt;nzcount() &gt; _b-&gt;nzcount())
        <a class="code" href="namespacecv.html#aee66fd35ceb08e5e93177b123481a25e" title="swaps two matrices">std::swap</a>(_a, _b);
     SparseMatConstIterator_&lt;float&gt; it = _a-&gt;begin&lt;<span class="keywordtype">float</span>&gt;(),
                                    it_end = _a-&gt;end&lt;<span class="keywordtype">float</span>&gt;();
     <span class="keywordtype">double</span> ccorr = 0;
     <span class="keywordflow">for</span>(; it != it_end; ++it)
     {
         <span class="comment">// take the next element from the first matrix</span>
         <span class="keywordtype">float</span> avalue = *it;
         <span class="keyword">const</span> Node* anode = it.node();
         <span class="comment">// and try to find element with the same index in the second matrix.</span>
         <span class="comment">// since the hash value depends only on the element index,</span>
         <span class="comment">// we reuse hashvalue stored in the node</span>
         <span class="keywordtype">float</span> bvalue = _b-&gt;value&lt;<span class="keywordtype">float</span>&gt;(anode-&gt;idx,&amp;anode-&gt;hashval);
         ccorr += avalue*bvalue;
     }
     <span class="keywordflow">return</span> ccorr;
 }
</pre></div> </li>
</ol>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aa766accd9ac415bea90019010f58cac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcv_1_1_sparse_mat_iterator.html">SparseMatIterator</a> <a class="el" href="classcv_1_1_sparse_mat.html#aa766accd9ac415bea90019010f58cac6">cv::SparseMat::iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#aad69108f160c710a9e39e540790cd630">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4f7803d5c41eef808081903167d3a263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcv_1_1_sparse_mat_const_iterator.html">SparseMatConstIterator</a> <a class="el" href="classcv_1_1_sparse_mat.html#a4f7803d5c41eef808081903167d3a263">cv::SparseMat::const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a60cda480e8a3854c706d9f56a119c8fd">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a7de4c57f754bb368c85152c1909cb65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7de4c57f754bb368c85152c1909cb65ba14d02d4adbcb5fa71d1922ceda241e8a"></a>MAGIC_VAL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7de4c57f754bb368c85152c1909cb65babe1aff4cd2b540afd5a3f4ffca3bd9a2"></a>MAX_DIM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7de4c57f754bb368c85152c1909cb65ba28ca477c8ed1afabd0da753827149eeb"></a>HASH_SCALE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7de4c57f754bb368c85152c1909cb65ba79cfd2c6ddc2c192623e8426429d27d1"></a>HASH_BIT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9b5f1214a43144122b158c354a93e338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">cv::SparseMat::SparseMat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>default constructor </p>

</div>
</div>
<a class="anchor" id="a62224fe4fbdc6134d80861a150e01b58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">cv::SparseMat::SparseMat</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creates matrix of the specified size and type </p>

</div>
</div>
<a class="anchor" id="a753add6192d4355c04e6e3594ab97b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">cv::SparseMat::SparseMat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy constructor </p>

</div>
</div>
<a class="anchor" id="af9432a94bda00c7fd2103bcd57654d03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">cv::SparseMat::SparseMat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts dense 2d matrix to the sparse form </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the input matrix </td></tr>
    <tr><td class="paramname">try1d</td><td>if true and m is a single-column matrix (Nx1), then the sparse matrix will be 1-dimensional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d812e359959b424068743618ecd2e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338">cv::SparseMat::SparseMat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts old-style sparse matrix to the new-style. All the data is copied </p>

</div>
</div>
<a class="anchor" id="a1903162ea8588b8dd0c4421824f8dd9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html#a1903162ea8588b8dd0c4421824f8dd9d">cv::SparseMat::~SparseMat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab80c24b3713add05c507ff56b3350ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp; cv::SparseMat::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>assignment operator. This is O(1) operation, i.e. no data is copied </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a0228e94614401ca21c6fe62dccc47365">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0ddfb53cd5f03f1b262d0f3c7b951f6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp; cv::SparseMat::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to the corresponding constructor </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#ae0a7d2ef10e45df805c4f77fc7e80487">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4c990be3ea562ab9f40c40edaf773a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> <a class="el" href="classcv_1_1_sparse_mat.html#a4c990be3ea562ab9f40c40edaf773a5d">cv::SparseMat::clone</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creates full copy of the matrix </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a1088d4110a7fcbdd08cd962b39dd4e5c">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a93c268b7c58435d8ecc3577f439283ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a93c268b7c58435d8ecc3577f439283ee">cv::SparseMat::copyTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copies all the data to the destination matrix. All the previous content of m is erased </p>

</div>
</div>
<a class="anchor" id="adb6344cbc400408f30300dd1a0112da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a93c268b7c58435d8ecc3577f439283ee">cv::SparseMat::copyTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts sparse matrix to dense matrix. </p>

</div>
</div>
<a class="anchor" id="a6ad5f495abf7eedede64afa7203b6b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a6ad5f495abf7eedede64afa7203b6b78">cv::SparseMat::convertTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type </p>

</div>
</div>
<a class="anchor" id="ac631bd31ae1ce1944ba6775f2ce121be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a6ad5f495abf7eedede64afa7203b6b78">cv::SparseMat::convertTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts sparse matrix to dense n-dim matrix with optional type conversion and scaling. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtype</td><td>The output matrix data type. When it is =-1, the output array will have the same data type as (*this) </td></tr>
    <tr><td class="paramname">alpha</td><td>The scale factor </td></tr>
    <tr><td class="paramname">beta</td><td>The optional delta added to the scaled values before the conversion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dfa0e1a634f76787997a495dd4bdbf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a0dfa0e1a634f76787997a495dd4bdbf0">cv::SparseMat::assignTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adf2713a5ec1fb025c9ff4014a53e68c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#adf2713a5ec1fb025c9ff4014a53e68c6">cv::SparseMat::create</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>reallocates sparse matrix. </p>
<p>If the matrix already had the proper size and type, it is simply cleared with <a class="el" href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e" title="sets all the sparse matrix elements to 0, which means clearing the hash table.">clear()</a>, otherwise, the old matrix is released (using <a class="el" href="classcv_1_1_sparse_mat.html#a3f4c162afd8cc809d23bd0fe9b38ead7">release()</a>) and the new one is allocated. </p>

</div>
</div>
<a class="anchor" id="a2fa705d84961513f6e0b0066ec245a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e">cv::SparseMat::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sets all the sparse matrix elements to 0, which means clearing the hash table. </p>

</div>
</div>
<a class="anchor" id="a8d1d03d3c19ccd8cd5653b3b7375bb68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a8d1d03d3c19ccd8cd5653b3b7375bb68">cv::SparseMat::addref</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>manually increments the reference counter to the header. </p>

</div>
</div>
<a class="anchor" id="a3f4c162afd8cc809d23bd0fe9b38ead7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a3f4c162afd8cc809d23bd0fe9b38ead7">cv::SparseMat::release</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b522e2f57e588c0f7cb4d3a3b69e8e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::SparseMat::operator <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a> * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts sparse matrix to the old-style representation; all the elements are copied. </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#ab7877c4f9221ec11652d357d0a402d67">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a00f7940230adaaad7bc231016c646f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#a00f7940230adaaad7bc231016c646f1e">cv::SparseMat::elemSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the size of each element in bytes (not including the overhead - the space occupied by <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html" title="sparse matrix node - element of a hash table">SparseMat::Node</a> elements) </p>

</div>
</div>
<a class="anchor" id="abe50d2428ea7bdc8fb74b48248036dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#abe50d2428ea7bdc8fb74b48248036dc6">cv::SparseMat::elemSize1</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns <a class="el" href="classcv_1_1_sparse_mat.html#a00f7940230adaaad7bc231016c646f1e" title="returns the size of each element in bytes (not including the overhead - the space occupied by SparseM...">elemSize()</a>/channels() </p>

</div>
</div>
<a class="anchor" id="a2611b9eb569ba46ea7013f17c22bfbf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#a2611b9eb569ba46ea7013f17c22bfbf8">cv::SparseMat::type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns type of sparse matrix elements </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a3cc1d8257f320f9843b8fcd23b087068">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a693e497e5384674c269d415e845dd74a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#a693e497e5384674c269d415e845dd74a">cv::SparseMat::depth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the depth of sparse matrix elements </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a32c205016a6771a833ea2210a666c02a">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad0c723bd46ceee0a6c88299fffa7a8b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#ad0c723bd46ceee0a6c88299fffa7a8b9">cv::SparseMat::channels</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the number of channels </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#aacc93a364ef5fb74b6db5945440e7cf2">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8257efe5b5a93b90da0daf89171012df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int * <a class="el" href="classcv_1_1_sparse_mat.html#a8257efe5b5a93b90da0daf89171012df">cv::SparseMat::size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the array of sizes, or NULL if the matrix is not allocated </p>

</div>
</div>
<a class="anchor" id="af4bd8427b4673af70a6eeeb4559c419a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#a8257efe5b5a93b90da0daf89171012df">cv::SparseMat::size</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the size of i-th matrix dimension (or 0) </p>

</div>
</div>
<a class="anchor" id="a3ff274ef6039cd6db69f156dcbb4ab93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">cv::SparseMat::dims</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the matrix dimensionality </p>

</div>
</div>
<a class="anchor" id="ab89d7c867e110b49316c6eb2d5d69f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ab89d7c867e110b49316c6eb2d5d69f85">cv::SparseMat::nzcount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the number of non-zero elements (=the number of hash table nodes) </p>

</div>
</div>
<a class="anchor" id="ac28efc048ec9585e0febb830d203fe8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">cv::SparseMat::hash</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes the element hash value (1D case) </p>

</div>
</div>
<a class="anchor" id="aa6f502942ecfb926d2a8879bd9dbc8a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">cv::SparseMat::hash</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes the element hash value (2D case) </p>

</div>
</div>
<a class="anchor" id="aba7d44641efd3c8de7b2bfbff023b384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">cv::SparseMat::hash</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes the element hash value (3D case) </p>

</div>
</div>
<a class="anchor" id="ac83549f5a561022195e387022ee9b06c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">cv::SparseMat::hash</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes the element hash value (nD case) </p>

</div>
</div>
<a class="anchor" id="a810b96cf23e3cc816e7f99473b81b513"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">cv::SparseMat::ptr</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case. </p>
<p>return pointer to the matrix element. </p>
<ul>
<li>
if the element is there (it's non-zero), the pointer to it is returned </li>
<li>
if it's not there and createMissing=false, NULL pointer is returned </li>
<li>
if it's not there and createMissing=true, then the new element is created and initialized with 0. Pointer to it is returned </li>
<li>
if the optional hashval pointer is not NULL, the element hash value is not computed, but *hashval is taken instead. </li>
</ul>
<p>returns pointer to the specified element (1D case) </p>

</div>
</div>
<a class="anchor" id="a14e7bb6106e6b4608ddbbc394bbf585e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">cv::SparseMat::ptr</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (2D case) </p>

</div>
</div>
<a class="anchor" id="afa0e9b6331a781f1d746e77582bee8a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">cv::SparseMat::ptr</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (3D case) </p>

</div>
</div>
<a class="anchor" id="a5425bac965f62767f50c7e68a7c452a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">cv::SparseMat::ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (nD case) </p>

</div>
</div>
<a class="anchor" id="a925b05f8347aaf82ec037fd823bb2a0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat.html#a925b05f8347aaf82ec037fd823bb2a0e">cv::SparseMat::ref</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return read-write reference to the specified sparse matrix element. </p>
<p>ref&lt;_Tp&gt;(i0,...[,hashval]) is equivalent to *(_Tp*)ptr(i0,...,true[,hashval]). The methods always return a valid reference. If the element did not exist, it is created and initialiazed with 0. returns reference to the specified element (1D case) </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a56d3ce739aecb0474616d5a7e74b50ed">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa027e36635c11e7b59fbf1f64a0d4798"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat.html#a925b05f8347aaf82ec037fd823bb2a0e">cv::SparseMat::ref</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns reference to the specified element (2D case) </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#add15b560c15b6e2c6364d4a8608451ca">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a533ec9897d2d9d1a151d07a05cced109"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat.html#a925b05f8347aaf82ec037fd823bb2a0e">cv::SparseMat::ref</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns reference to the specified element (3D case) </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#ac40f0bddc8f4f66701f57f0f63d249af">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4e7feaec46317e5dae1d2de5c3aa9c18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat.html#a925b05f8347aaf82ec037fd823bb2a0e">cv::SparseMat::ref</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns reference to the specified element (nD case) </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a89fdd145e3a1f0baf354063bf3b21326">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a25af0320f3323181aeb16eae3a2cca55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return value of the specified sparse matrix element. </p>
<div class="fragment"><pre class="fragment">value&lt;_Tp&gt;(i0,...[,hashval]) is equivalent</pre></div> <div class="fragment"><pre class="fragment">     { <span class="keyword">const</span> _Tp* p = find&lt;_Tp&gt;(i0,...[,hashval]); <span class="keywordflow">return</span> p ? *p : _Tp(); }
</pre></div><p>That is, if the element did not exist, the methods return 0. returns value of the specified element (1D case) </p>

</div>
</div>
<a class="anchor" id="a0d254b1881f2a92080c34590034e48bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns value of the specified element (2D case) </p>

</div>
</div>
<a class="anchor" id="a288c58847a9cc310940f0f76f3dfce53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns value of the specified element (3D case) </p>

</div>
</div>
<a class="anchor" id="a948563f1181b81c52b7a600538fa9657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns value of the specified element (nD case) </p>

</div>
</div>
<a class="anchor" id="a46196f5a4b345c43a6ee344d4daee171"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">cv::SparseMat::find</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return pointer to the specified sparse matrix element if it exists. </p>
<p>find&lt;_Tp&gt;(i0,...[,hashval]) is equivalent to (_const Tp*)ptr(i0,...false[,hashval]).</p>
<p>If the specified element does not exist, the methods return NULL. returns pointer to the specified element (1D case) </p>

</div>
</div>
<a class="anchor" id="af5166def1d0ee208e61c13194d736c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">cv::SparseMat::find</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (2D case) </p>

</div>
</div>
<a class="anchor" id="a76f091d90c610bc7c62404a5115fdd2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">cv::SparseMat::find</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (3D case) </p>

</div>
</div>
<a class="anchor" id="a01119d63e21697f1691b16cc1a00628a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">cv::SparseMat::find</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (nD case) </p>

</div>
</div>
<a class="anchor" id="ad4ff041a2a3771613847b94c761ab1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">cv::SparseMat::erase</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>erases the specified element (2D case) </p>

</div>
</div>
<a class="anchor" id="ab00d2c0c7bff3c631d1ac43fe1be45cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">cv::SparseMat::erase</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>erases the specified element (3D case) </p>

</div>
</div>
<a class="anchor" id="a6f64485a3f47ba79847a3fdf349b9943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">cv::SparseMat::erase</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>erases the specified element (nD case) </p>

</div>
</div>
<a class="anchor" id="a45125aae0952d6b9777be600a8955a06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat.html#a45125aae0952d6b9777be600a8955a06">cv::SparseMat::begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the sparse matrix iterator pointing to the first sparse matrix element </p>
<p>returns the sparse matrix iterator at the matrix beginning </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a63186dc2e14f7f06c4a9d08ffd66b604">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af371f2cb6952b62ec7ad3b82538d9363"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt;_Tp&gt; <a class="el" href="classcv_1_1_sparse_mat.html#a45125aae0952d6b9777be600a8955a06">cv::SparseMat::begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the sparse matrix iterator at the matrix beginning </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a63186dc2e14f7f06c4a9d08ffd66b604">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae70ca8ec2bf3945f832870ab7296c536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat.html#a45125aae0952d6b9777be600a8955a06">cv::SparseMat::begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the read-only sparse matrix iterator at the matrix beginning </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a088f5e1c127e37274d2617802035a0a9">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1f52049dc822a75abf2f1d956e2b48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt;_Tp&gt; <a class="el" href="classcv_1_1_sparse_mat.html#a45125aae0952d6b9777be600a8955a06">cv::SparseMat::begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the read-only sparse matrix iterator at the matrix beginning </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a088f5e1c127e37274d2617802035a0a9">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af5f0a657ed8469a56236df5082bbb78e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat.html#af5f0a657ed8469a56236df5082bbb78e">cv::SparseMat::end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return the sparse matrix iterator pointing to the element following the last sparse matrix element </p>
<p>returns the sparse matrix iterator at the matrix end </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a1d72b84fbcf318872bb8a497581ffbf8">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1d3e2e9de51dfa3a519e9489876eee7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat.html#af5f0a657ed8469a56236df5082bbb78e">cv::SparseMat::end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the read-only sparse matrix iterator at the matrix end </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a6d2dd53fde36d82424df7038f249c06f">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4fe2ca854bcafa54cb371146523c7e36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt;_Tp&gt; <a class="el" href="classcv_1_1_sparse_mat.html#af5f0a657ed8469a56236df5082bbb78e">cv::SparseMat::end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the typed sparse matrix iterator at the matrix end </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a1d72b84fbcf318872bb8a497581ffbf8">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a037118a6224726aad087e3e9258f57b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt;_Tp&gt; <a class="el" href="classcv_1_1_sparse_mat.html#af5f0a657ed8469a56236df5082bbb78e">cv::SparseMat::end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the typed read-only sparse matrix iterator at the matrix end </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_sparse_mat__.html#a6d2dd53fde36d82424df7038f249c06f">cv::SparseMat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afe08b740792d6e7f31706616685b70f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the value stored in the sparse martix node </p>

</div>
</div>
<a class="anchor" id="a18d86c436d847195806cf3c1dd07751f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the value stored in the sparse martix node </p>

</div>
</div>
<a class="anchor" id="a6255da02af3f6d71c2d4dfcc9b94a524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">SparseMat::Node</a> * <a class="el" href="classcv_1_1_sparse_mat.html#a6255da02af3f6d71c2d4dfcc9b94a524">cv::SparseMat::node</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nidx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac384b30f4c291e6a2526c69dc3de0c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">SparseMat::Node</a> * <a class="el" href="classcv_1_1_sparse_mat.html#a6255da02af3f6d71c2d4dfcc9b94a524">cv::SparseMat::node</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nidx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acfbf3c27ab6d5f90e4d37b1654f90f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#acfbf3c27ab6d5f90e4d37b1654f90f0a">cv::SparseMat::newNode</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hashval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5adcb69ee679da35f74ea3a78594a692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a5adcb69ee679da35f74ea3a78594a692">cv::SparseMat::removeNode</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>previdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af86523883daef3f618a7ec38fe049edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#af86523883daef3f618a7ec38fe049edc">cv::SparseMat::resizeHashTab</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad5f261bc8c1330e4e516684861410cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#ad5f261bc8c1330e4e516684861410cd2">cv::SparseMat::flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3741ff43acd46b31aace23dee092d85a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">Hdr</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a3741ff43acd46b31aace23dee092d85a">cv::SparseMat::hdr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/opencv2/core/<a class="el" href="core_8hpp_source.html">core.hpp</a></li>
<li>include/opencv2/core/<a class="el" href="mat_8hpp_source.html">mat.hpp</a></li>
</ul>
</div><!-- contents -->
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>
