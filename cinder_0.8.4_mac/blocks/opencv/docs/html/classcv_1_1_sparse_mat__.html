<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacecv.html">cv</a>      </li>
      <li class="navelem"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cv::SparseMat_&lt; _Tp &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Template Sparse Matrix class derived from <a class="el" href="classcv_1_1_sparse_mat.html" title="Sparse matrix class.">cv::SparseMat</a>.  
 <a href="classcv_1_1_sparse_mat__.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_8hpp_source.html">core.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="classcv_1_1_sparse_mat.html">cv::SparseMat</a>.</p>

<p><a href="classcv_1_1_sparse_mat__-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aad69108f160c710a9e39e540790cd630"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#aad69108f160c710a9e39e540790cd630">iterator</a></td></tr>
<tr class="memitem:a60cda480e8a3854c706d9f56a119c8fd"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a60cda480e8a3854c706d9f56a119c8fd">const_iterator</a></td></tr>
<tr class="memitem:a7de4c57f754bb368c85152c1909cb65b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classcv_1_1_sparse_mat.html#a7de4c57f754bb368c85152c1909cb65ba14d02d4adbcb5fa71d1922ceda241e8a">MAGIC_VAL</a> = 0x42FD0000, 
<a class="el" href="classcv_1_1_sparse_mat.html#a7de4c57f754bb368c85152c1909cb65babe1aff4cd2b540afd5a3f4ffca3bd9a2">MAX_DIM</a> = CV_MAX_DIM, 
<a class="el" href="classcv_1_1_sparse_mat.html#a7de4c57f754bb368c85152c1909cb65ba28ca477c8ed1afabd0da753827149eeb">HASH_SCALE</a> = 0x5bd1e995, 
<a class="el" href="classcv_1_1_sparse_mat.html#a7de4c57f754bb368c85152c1909cb65ba79cfd2c6ddc2c192623e8426429d27d1">HASH_BIT</a> = 0x80000000
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a359e83f7b4372d439ad31a84e72cd12d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a359e83f7b4372d439ad31a84e72cd12d">SparseMat_</a> ()</td></tr>
<tr class="memdesc:a359e83f7b4372d439ad31a84e72cd12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the default constructor  <a href="#a359e83f7b4372d439ad31a84e72cd12d"></a><br/></td></tr>
<tr class="memitem:adb611458d46e670dcaf099f1fceddf9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#adb611458d46e670dcaf099f1fceddf9c">SparseMat_</a> (int <a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">dims</a>, const int *_sizes)</td></tr>
<tr class="memdesc:adb611458d46e670dcaf099f1fceddf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the full constructor equivelent to SparseMat(dims, _sizes, DataType&lt;_Tp&gt;::type)  <a href="#adb611458d46e670dcaf099f1fceddf9c"></a><br/></td></tr>
<tr class="memitem:ab0e9b029a622c637e17f8288d968f25c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#ab0e9b029a622c637e17f8288d968f25c">SparseMat_</a> (const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m)</td></tr>
<tr class="memdesc:ab0e9b029a622c637e17f8288d968f25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the copy constructor. If DataType&lt;_Tp&gt;.type != m.type(), the m elements are converted  <a href="#ab0e9b029a622c637e17f8288d968f25c"></a><br/></td></tr>
<tr class="memitem:a773ae7065a51b5440d0d9c8b87b7eba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a773ae7065a51b5440d0d9c8b87b7eba3">SparseMat_</a> (const <a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> &amp;m)</td></tr>
<tr class="memdesc:a773ae7065a51b5440d0d9c8b87b7eba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the copy constructor. This is O(1) operation - no data is copied  <a href="#a773ae7065a51b5440d0d9c8b87b7eba3"></a><br/></td></tr>
<tr class="memitem:a0938540b46ceeca038f396f019b1e3c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a0938540b46ceeca038f396f019b1e3c4">SparseMat_</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr class="memdesc:a0938540b46ceeca038f396f019b1e3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts dense matrix to the sparse form  <a href="#a0938540b46ceeca038f396f019b1e3c4"></a><br/></td></tr>
<tr class="memitem:aadc604a842e482ee41b4d345b4c6504e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#aadc604a842e482ee41b4d345b4c6504e">SparseMat_</a> (const <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a> *m)</td></tr>
<tr class="memdesc:aadc604a842e482ee41b4d345b4c6504e"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts the old-style sparse matrix to the C++ class. All the elements are copied  <a href="#aadc604a842e482ee41b4d345b4c6504e"></a><br/></td></tr>
<tr class="memitem:a0228e94614401ca21c6fe62dccc47365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a0228e94614401ca21c6fe62dccc47365">operator=</a> (const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m)</td></tr>
<tr class="memdesc:a0228e94614401ca21c6fe62dccc47365"><td class="mdescLeft">&#160;</td><td class="mdescRight">the assignment operator. If DataType&lt;_Tp&gt;.type != m.type(), the m elements are converted  <a href="#a0228e94614401ca21c6fe62dccc47365"></a><br/></td></tr>
<tr class="memitem:ac2f76c0259e2b23e8ae0837c6a328331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#ac2f76c0259e2b23e8ae0837c6a328331">operator=</a> (const <a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> &amp;m)</td></tr>
<tr class="memdesc:ac2f76c0259e2b23e8ae0837c6a328331"><td class="mdescLeft">&#160;</td><td class="mdescRight">the assignment operator. This is O(1) operation - no data is copied  <a href="#ac2f76c0259e2b23e8ae0837c6a328331"></a><br/></td></tr>
<tr class="memitem:ae0a7d2ef10e45df805c4f77fc7e80487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#ae0a7d2ef10e45df805c4f77fc7e80487">operator=</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr class="memdesc:ae0a7d2ef10e45df805c4f77fc7e80487"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts dense matrix to the sparse form  <a href="#ae0a7d2ef10e45df805c4f77fc7e80487"></a><br/></td></tr>
<tr class="memitem:a1088d4110a7fcbdd08cd962b39dd4e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a1088d4110a7fcbdd08cd962b39dd4e5c">clone</a> () const </td></tr>
<tr class="memdesc:a1088d4110a7fcbdd08cd962b39dd4e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes full copy of the matrix. All the elements are duplicated  <a href="#a1088d4110a7fcbdd08cd962b39dd4e5c"></a><br/></td></tr>
<tr class="memitem:a18a20736ff3a669e99e041d1c4fa7110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a18a20736ff3a669e99e041d1c4fa7110">create</a> (int <a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">dims</a>, const int *_sizes)</td></tr>
<tr class="memdesc:a18a20736ff3a669e99e041d1c4fa7110"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to cv::SparseMat::create(dims, _sizes, DataType&lt;_Tp&gt;::type)  <a href="#a18a20736ff3a669e99e041d1c4fa7110"></a><br/></td></tr>
<tr class="memitem:ab7877c4f9221ec11652d357d0a402d67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#ab7877c4f9221ec11652d357d0a402d67">operator CvSparseMat *</a> () const </td></tr>
<tr class="memdesc:ab7877c4f9221ec11652d357d0a402d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to the old-style <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a>. All the elements are copied  <a href="#ab7877c4f9221ec11652d357d0a402d67"></a><br/></td></tr>
<tr class="memitem:a3cc1d8257f320f9843b8fcd23b087068"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a3cc1d8257f320f9843b8fcd23b087068">type</a> () const </td></tr>
<tr class="memdesc:a3cc1d8257f320f9843b8fcd23b087068"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns type of the matrix elements  <a href="#a3cc1d8257f320f9843b8fcd23b087068"></a><br/></td></tr>
<tr class="memitem:a32c205016a6771a833ea2210a666c02a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a32c205016a6771a833ea2210a666c02a">depth</a> () const </td></tr>
<tr class="memdesc:a32c205016a6771a833ea2210a666c02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns depth of the matrix elements  <a href="#a32c205016a6771a833ea2210a666c02a"></a><br/></td></tr>
<tr class="memitem:aacc93a364ef5fb74b6db5945440e7cf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#aacc93a364ef5fb74b6db5945440e7cf2">channels</a> () const </td></tr>
<tr class="memdesc:aacc93a364ef5fb74b6db5945440e7cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of channels in each matrix element  <a href="#aacc93a364ef5fb74b6db5945440e7cf2"></a><br/></td></tr>
<tr class="memitem:a56d3ce739aecb0474616d5a7e74b50ed"><td class="memItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a56d3ce739aecb0474616d5a7e74b50ed">ref</a> (int i0, size_t *hashval=0)</td></tr>
<tr class="memdesc:a56d3ce739aecb0474616d5a7e74b50ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to SparseMat::ref&lt;_Tp&gt;(i0, hashval)  <a href="#a56d3ce739aecb0474616d5a7e74b50ed"></a><br/></td></tr>
<tr class="memitem:add15b560c15b6e2c6364d4a8608451ca"><td class="memItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#add15b560c15b6e2c6364d4a8608451ca">ref</a> (int i0, int i1, size_t *hashval=0)</td></tr>
<tr class="memdesc:add15b560c15b6e2c6364d4a8608451ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to SparseMat::ref&lt;_Tp&gt;(i0, i1, hashval)  <a href="#add15b560c15b6e2c6364d4a8608451ca"></a><br/></td></tr>
<tr class="memitem:ac40f0bddc8f4f66701f57f0f63d249af"><td class="memItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#ac40f0bddc8f4f66701f57f0f63d249af">ref</a> (int i0, int i1, int i2, size_t *hashval=0)</td></tr>
<tr class="memdesc:ac40f0bddc8f4f66701f57f0f63d249af"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to SparseMat::ref&lt;_Tp&gt;(i0, i1, i2, hashval)  <a href="#ac40f0bddc8f4f66701f57f0f63d249af"></a><br/></td></tr>
<tr class="memitem:a89fdd145e3a1f0baf354063bf3b21326"><td class="memItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a89fdd145e3a1f0baf354063bf3b21326">ref</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0)</td></tr>
<tr class="memdesc:a89fdd145e3a1f0baf354063bf3b21326"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to SparseMat::ref&lt;_Tp&gt;(idx, hashval)  <a href="#a89fdd145e3a1f0baf354063bf3b21326"></a><br/></td></tr>
<tr class="memitem:a77b48da371733121726faf1912499795"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a77b48da371733121726faf1912499795">operator()</a> (int i0, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a77b48da371733121726faf1912499795"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to SparseMat::value&lt;_Tp&gt;(i0, hashval)  <a href="#a77b48da371733121726faf1912499795"></a><br/></td></tr>
<tr class="memitem:a4b77893d6317a9cb708638999037cb2b"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a4b77893d6317a9cb708638999037cb2b">operator()</a> (int i0, int i1, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a4b77893d6317a9cb708638999037cb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to SparseMat::value&lt;_Tp&gt;(i0, i1, hashval)  <a href="#a4b77893d6317a9cb708638999037cb2b"></a><br/></td></tr>
<tr class="memitem:a783ca400b585d995331b7c0ecc658cf0"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a783ca400b585d995331b7c0ecc658cf0">operator()</a> (int i0, int i1, int i2, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a783ca400b585d995331b7c0ecc658cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to SparseMat::value&lt;_Tp&gt;(i0, i1, i2, hashval)  <a href="#a783ca400b585d995331b7c0ecc658cf0"></a><br/></td></tr>
<tr class="memitem:a22387ba6aa8ce9cd59246775e1dffe2b"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a22387ba6aa8ce9cd59246775e1dffe2b">operator()</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a22387ba6aa8ce9cd59246775e1dffe2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to SparseMat::value&lt;_Tp&gt;(idx, hashval)  <a href="#a22387ba6aa8ce9cd59246775e1dffe2b"></a><br/></td></tr>
<tr class="memitem:a63186dc2e14f7f06c4a9d08ffd66b604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a63186dc2e14f7f06c4a9d08ffd66b604">begin</a> ()</td></tr>
<tr class="memdesc:a63186dc2e14f7f06c4a9d08ffd66b604"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sparse matrix iterator pointing to the first sparse matrix element  <a href="#a63186dc2e14f7f06c4a9d08ffd66b604"></a><br/></td></tr>
<tr class="memitem:a088f5e1c127e37274d2617802035a0a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a088f5e1c127e37274d2617802035a0a9">begin</a> () const </td></tr>
<tr class="memdesc:a088f5e1c127e37274d2617802035a0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns read-only sparse matrix iterator pointing to the first sparse matrix element  <a href="#a088f5e1c127e37274d2617802035a0a9"></a><br/></td></tr>
<tr class="memitem:a1d72b84fbcf318872bb8a497581ffbf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a1d72b84fbcf318872bb8a497581ffbf8">end</a> ()</td></tr>
<tr class="memdesc:a1d72b84fbcf318872bb8a497581ffbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sparse matrix iterator pointing to the element following the last sparse matrix element  <a href="#a1d72b84fbcf318872bb8a497581ffbf8"></a><br/></td></tr>
<tr class="memitem:a6d2dd53fde36d82424df7038f249c06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat__.html#a6d2dd53fde36d82424df7038f249c06f">end</a> () const </td></tr>
<tr class="memdesc:a6d2dd53fde36d82424df7038f249c06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns read-only sparse matrix iterator pointing to the element following the last sparse matrix element  <a href="#a6d2dd53fde36d82424df7038f249c06f"></a><br/></td></tr>
<tr class="memitem:a93c268b7c58435d8ecc3577f439283ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a93c268b7c58435d8ecc3577f439283ee">copyTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m) const </td></tr>
<tr class="memdesc:a93c268b7c58435d8ecc3577f439283ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies all the data to the destination matrix. All the previous content of m is erased  <a href="#a93c268b7c58435d8ecc3577f439283ee"></a><br/></td></tr>
<tr class="memitem:adb6344cbc400408f30300dd1a0112da9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#adb6344cbc400408f30300dd1a0112da9">copyTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m) const </td></tr>
<tr class="memdesc:adb6344cbc400408f30300dd1a0112da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to dense matrix.  <a href="#adb6344cbc400408f30300dd1a0112da9"></a><br/></td></tr>
<tr class="memitem:a6ad5f495abf7eedede64afa7203b6b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6ad5f495abf7eedede64afa7203b6b78">convertTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m, int rtype, double <a class="el" href="legacy_8hpp.html#a95fc8341ca418bc06b36160632af6d47">alpha</a>=1) const </td></tr>
<tr class="memdesc:a6ad5f495abf7eedede64afa7203b6b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type  <a href="#a6ad5f495abf7eedede64afa7203b6b78"></a><br/></td></tr>
<tr class="memitem:ac631bd31ae1ce1944ba6775f2ce121be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac631bd31ae1ce1944ba6775f2ce121be">convertTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, int rtype, double <a class="el" href="legacy_8hpp.html#a95fc8341ca418bc06b36160632af6d47">alpha</a>=1, double <a class="el" href="legacy_8hpp.html#af8b31eb489dfbd87f3b1a1925cca3589">beta</a>=0) const </td></tr>
<tr class="memdesc:ac631bd31ae1ce1944ba6775f2ce121be"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts sparse matrix to dense n-dim matrix with optional type conversion and scaling.  <a href="#ac631bd31ae1ce1944ba6775f2ce121be"></a><br/></td></tr>
<tr class="memitem:a0dfa0e1a634f76787997a495dd4bdbf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a0dfa0e1a634f76787997a495dd4bdbf0">assignTo</a> (<a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;m, int <a class="el" href="classcv_1_1_sparse_mat__.html#a3cc1d8257f320f9843b8fcd23b087068">type</a>=-1) const </td></tr>
<tr class="memitem:adf2713a5ec1fb025c9ff4014a53e68c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#adf2713a5ec1fb025c9ff4014a53e68c6">create</a> (int <a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">dims</a>, const int *_sizes, int _type)</td></tr>
<tr class="memdesc:adf2713a5ec1fb025c9ff4014a53e68c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">reallocates sparse matrix.  <a href="#adf2713a5ec1fb025c9ff4014a53e68c6"></a><br/></td></tr>
<tr class="memitem:a2fa705d84961513f6e0b0066ec245a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e">clear</a> ()</td></tr>
<tr class="memdesc:a2fa705d84961513f6e0b0066ec245a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets all the sparse matrix elements to 0, which means clearing the hash table.  <a href="#a2fa705d84961513f6e0b0066ec245a8e"></a><br/></td></tr>
<tr class="memitem:a8d1d03d3c19ccd8cd5653b3b7375bb68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a8d1d03d3c19ccd8cd5653b3b7375bb68">addref</a> ()</td></tr>
<tr class="memdesc:a8d1d03d3c19ccd8cd5653b3b7375bb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">manually increments the reference counter to the header.  <a href="#a8d1d03d3c19ccd8cd5653b3b7375bb68"></a><br/></td></tr>
<tr class="memitem:a3f4c162afd8cc809d23bd0fe9b38ead7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3f4c162afd8cc809d23bd0fe9b38ead7">release</a> ()</td></tr>
<tr class="memitem:a00f7940230adaaad7bc231016c646f1e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a00f7940230adaaad7bc231016c646f1e">elemSize</a> () const </td></tr>
<tr class="memdesc:a00f7940230adaaad7bc231016c646f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of each element in bytes (not including the overhead - the space occupied by <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html" title="sparse matrix node - element of a hash table">SparseMat::Node</a> elements)  <a href="#a00f7940230adaaad7bc231016c646f1e"></a><br/></td></tr>
<tr class="memitem:abe50d2428ea7bdc8fb74b48248036dc6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#abe50d2428ea7bdc8fb74b48248036dc6">elemSize1</a> () const </td></tr>
<tr class="memdesc:abe50d2428ea7bdc8fb74b48248036dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="classcv_1_1_sparse_mat.html#a00f7940230adaaad7bc231016c646f1e" title="returns the size of each element in bytes (not including the overhead - the space occupied by SparseM...">elemSize()</a>/channels()  <a href="#abe50d2428ea7bdc8fb74b48248036dc6"></a><br/></td></tr>
<tr class="memitem:a8257efe5b5a93b90da0daf89171012df"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a8257efe5b5a93b90da0daf89171012df">size</a> () const </td></tr>
<tr class="memdesc:a8257efe5b5a93b90da0daf89171012df"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the array of sizes, or NULL if the matrix is not allocated  <a href="#a8257efe5b5a93b90da0daf89171012df"></a><br/></td></tr>
<tr class="memitem:af4bd8427b4673af70a6eeeb4559c419a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af4bd8427b4673af70a6eeeb4559c419a">size</a> (int i) const </td></tr>
<tr class="memdesc:af4bd8427b4673af70a6eeeb4559c419a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of i-th matrix dimension (or 0)  <a href="#af4bd8427b4673af70a6eeeb4559c419a"></a><br/></td></tr>
<tr class="memitem:a3ff274ef6039cd6db69f156dcbb4ab93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">dims</a> () const </td></tr>
<tr class="memdesc:a3ff274ef6039cd6db69f156dcbb4ab93"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the matrix dimensionality  <a href="#a3ff274ef6039cd6db69f156dcbb4ab93"></a><br/></td></tr>
<tr class="memitem:ab89d7c867e110b49316c6eb2d5d69f85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ab89d7c867e110b49316c6eb2d5d69f85">nzcount</a> () const </td></tr>
<tr class="memdesc:ab89d7c867e110b49316c6eb2d5d69f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of non-zero elements (=the number of hash table nodes)  <a href="#ab89d7c867e110b49316c6eb2d5d69f85"></a><br/></td></tr>
<tr class="memitem:ac28efc048ec9585e0febb830d203fe8b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">hash</a> (int i0) const </td></tr>
<tr class="memdesc:ac28efc048ec9585e0febb830d203fe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (1D case)  <a href="#ac28efc048ec9585e0febb830d203fe8b"></a><br/></td></tr>
<tr class="memitem:aa6f502942ecfb926d2a8879bd9dbc8a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aa6f502942ecfb926d2a8879bd9dbc8a9">hash</a> (int i0, int i1) const </td></tr>
<tr class="memdesc:aa6f502942ecfb926d2a8879bd9dbc8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (2D case)  <a href="#aa6f502942ecfb926d2a8879bd9dbc8a9"></a><br/></td></tr>
<tr class="memitem:aba7d44641efd3c8de7b2bfbff023b384"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#aba7d44641efd3c8de7b2bfbff023b384">hash</a> (int i0, int i1, int i2) const </td></tr>
<tr class="memdesc:aba7d44641efd3c8de7b2bfbff023b384"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (3D case)  <a href="#aba7d44641efd3c8de7b2bfbff023b384"></a><br/></td></tr>
<tr class="memitem:ac83549f5a561022195e387022ee9b06c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac83549f5a561022195e387022ee9b06c">hash</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>) const </td></tr>
<tr class="memdesc:ac83549f5a561022195e387022ee9b06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element hash value (nD case)  <a href="#ac83549f5a561022195e387022ee9b06c"></a><br/></td></tr>
<tr class="memitem:afe08b740792d6e7f31706616685b70f9"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:afe08b740792d6e7f31706616685b70f9"><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#afe08b740792d6e7f31706616685b70f9">value</a> (<a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *<a class="el" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="memdesc:afe08b740792d6e7f31706616685b70f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value stored in the sparse martix node  <a href="#afe08b740792d6e7f31706616685b70f9"></a><br/></td></tr>
<tr class="memitem:a18d86c436d847195806cf3c1dd07751f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a18d86c436d847195806cf3c1dd07751f"><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a18d86c436d847195806cf3c1dd07751f">value</a> (const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *<a class="el" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>) const </td></tr>
<tr class="memdesc:a18d86c436d847195806cf3c1dd07751f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value stored in the sparse martix node  <a href="#a18d86c436d847195806cf3c1dd07751f"></a><br/></td></tr>
<tr class="memitem:a6255da02af3f6d71c2d4dfcc9b94a524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6255da02af3f6d71c2d4dfcc9b94a524">node</a> (size_t nidx)</td></tr>
<tr class="memitem:ac384b30f4c291e6a2526c69dc3de0c98"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ac384b30f4c291e6a2526c69dc3de0c98">node</a> (size_t nidx) const </td></tr>
<tr class="memitem:acfbf3c27ab6d5f90e4d37b1654f90f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#acfbf3c27ab6d5f90e4d37b1654f90f0a">newNode</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t hashval)</td></tr>
<tr class="memitem:a5adcb69ee679da35f74ea3a78594a692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a5adcb69ee679da35f74ea3a78594a692">removeNode</a> (size_t hidx, size_t nidx, size_t previdx)</td></tr>
<tr class="memitem:af86523883daef3f618a7ec38fe049edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af86523883daef3f618a7ec38fe049edc">resizeHashTab</a> (size_t newsize)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a810b96cf23e3cc816e7f99473b81b513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">ptr</a> (int i0, bool createMissing, size_t *hashval=0)</td></tr>
<tr class="memdesc:a810b96cf23e3cc816e7f99473b81b513"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case.  <a href="#a810b96cf23e3cc816e7f99473b81b513"></a><br/></td></tr>
<tr class="memitem:a14e7bb6106e6b4608ddbbc394bbf585e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a14e7bb6106e6b4608ddbbc394bbf585e">ptr</a> (int i0, int i1, bool createMissing, size_t *hashval=0)</td></tr>
<tr class="memdesc:a14e7bb6106e6b4608ddbbc394bbf585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (2D case)  <a href="#a14e7bb6106e6b4608ddbbc394bbf585e"></a><br/></td></tr>
<tr class="memitem:afa0e9b6331a781f1d746e77582bee8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#afa0e9b6331a781f1d746e77582bee8a8">ptr</a> (int i0, int i1, int i2, bool createMissing, size_t *hashval=0)</td></tr>
<tr class="memdesc:afa0e9b6331a781f1d746e77582bee8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (3D case)  <a href="#afa0e9b6331a781f1d746e77582bee8a8"></a><br/></td></tr>
<tr class="memitem:a5425bac965f62767f50c7e68a7c452a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a5425bac965f62767f50c7e68a7c452a0">ptr</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, bool createMissing, size_t *hashval=0)</td></tr>
<tr class="memdesc:a5425bac965f62767f50c7e68a7c452a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (nD case)  <a href="#a5425bac965f62767f50c7e68a7c452a0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a25af0320f3323181aeb16eae3a2cca55"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a25af0320f3323181aeb16eae3a2cca55"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">value</a> (int i0, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a25af0320f3323181aeb16eae3a2cca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">return value of the specified sparse matrix element.  <a href="#a25af0320f3323181aeb16eae3a2cca55"></a><br/></td></tr>
<tr class="memitem:a0d254b1881f2a92080c34590034e48bd"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a0d254b1881f2a92080c34590034e48bd"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a0d254b1881f2a92080c34590034e48bd">value</a> (int i0, int i1, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a0d254b1881f2a92080c34590034e48bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (2D case)  <a href="#a0d254b1881f2a92080c34590034e48bd"></a><br/></td></tr>
<tr class="memitem:a288c58847a9cc310940f0f76f3dfce53"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a288c58847a9cc310940f0f76f3dfce53"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a288c58847a9cc310940f0f76f3dfce53">value</a> (int i0, int i1, int i2, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a288c58847a9cc310940f0f76f3dfce53"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (3D case)  <a href="#a288c58847a9cc310940f0f76f3dfce53"></a><br/></td></tr>
<tr class="memitem:a948563f1181b81c52b7a600538fa9657"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a948563f1181b81c52b7a600538fa9657"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a948563f1181b81c52b7a600538fa9657">value</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a948563f1181b81c52b7a600538fa9657"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns value of the specified element (nD case)  <a href="#a948563f1181b81c52b7a600538fa9657"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a46196f5a4b345c43a6ee344d4daee171"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a46196f5a4b345c43a6ee344d4daee171"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">find</a> (int i0, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a46196f5a4b345c43a6ee344d4daee171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the specified sparse matrix element if it exists.  <a href="#a46196f5a4b345c43a6ee344d4daee171"></a><br/></td></tr>
<tr class="memitem:af5166def1d0ee208e61c13194d736c13"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af5166def1d0ee208e61c13194d736c13"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#af5166def1d0ee208e61c13194d736c13">find</a> (int i0, int i1, size_t *hashval=0) const </td></tr>
<tr class="memdesc:af5166def1d0ee208e61c13194d736c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (2D case)  <a href="#af5166def1d0ee208e61c13194d736c13"></a><br/></td></tr>
<tr class="memitem:a76f091d90c610bc7c62404a5115fdd2d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a76f091d90c610bc7c62404a5115fdd2d"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a76f091d90c610bc7c62404a5115fdd2d">find</a> (int i0, int i1, int i2, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a76f091d90c610bc7c62404a5115fdd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (3D case)  <a href="#a76f091d90c610bc7c62404a5115fdd2d"></a><br/></td></tr>
<tr class="memitem:a01119d63e21697f1691b16cc1a00628a"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a01119d63e21697f1691b16cc1a00628a"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a01119d63e21697f1691b16cc1a00628a">find</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0) const </td></tr>
<tr class="memdesc:a01119d63e21697f1691b16cc1a00628a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the specified element (nD case)  <a href="#a01119d63e21697f1691b16cc1a00628a"></a><br/></td></tr>
<tr class="memitem:ad4ff041a2a3771613847b94c761ab1f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">erase</a> (int i0, int i1, size_t *hashval=0)</td></tr>
<tr class="memdesc:ad4ff041a2a3771613847b94c761ab1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (2D case)  <a href="#ad4ff041a2a3771613847b94c761ab1f4"></a><br/></td></tr>
<tr class="memitem:ab00d2c0c7bff3c631d1ac43fe1be45cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ab00d2c0c7bff3c631d1ac43fe1be45cd">erase</a> (int i0, int i1, int i2, size_t *hashval=0)</td></tr>
<tr class="memdesc:ab00d2c0c7bff3c631d1ac43fe1be45cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (3D case)  <a href="#ab00d2c0c7bff3c631d1ac43fe1be45cd"></a><br/></td></tr>
<tr class="memitem:a6f64485a3f47ba79847a3fdf349b9943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a6f64485a3f47ba79847a3fdf349b9943">erase</a> (const int *<a class="el" href="core__c_8h.html#a5c7c842f447336aa2f10826df65a28b3">idx</a>, size_t *hashval=0)</td></tr>
<tr class="memdesc:a6f64485a3f47ba79847a3fdf349b9943"><td class="mdescLeft">&#160;</td><td class="mdescRight">erases the specified element (nD case)  <a href="#a6f64485a3f47ba79847a3fdf349b9943"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad5f261bc8c1330e4e516684861410cd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#ad5f261bc8c1330e4e516684861410cd2">flags</a></td></tr>
<tr class="memitem:a3741ff43acd46b31aace23dee092d85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">Hdr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_sparse_mat.html#a3741ff43acd46b31aace23dee092d85a">hdr</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Tp&gt;<br/>
class cv::SparseMat_&lt; _Tp &gt;</h3>

<p>The Template Sparse Matrix class derived from <a class="el" href="classcv_1_1_sparse_mat.html" title="Sparse matrix class.">cv::SparseMat</a>. </p>
<p>The class provides slightly more convenient operations for accessing elements.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcv_1_1_sparse_mat.html#a9b5f1214a43144122b158c354a93e338" title="default constructor">SparseMat</a> m;
 ...
 SparseMat_&lt;int&gt; m_ = (SparseMat_&lt;int&gt;&amp;)m;
 m_.ref(1)++; <span class="comment">// equivalent to m.ref&lt;int&gt;(1)++;</span>
 m_.ref(2) += m_(3); <span class="comment">// equivalent to m.ref&lt;int&gt;(2) += m.value&lt;int&gt;(3);</span>
</pre></div> </div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aad69108f160c710a9e39e540790cd630"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt;_Tp&gt; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat.html#aa766accd9ac415bea90019010f58cac6">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#aa766accd9ac415bea90019010f58cac6">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a60cda480e8a3854c706d9f56a119c8fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt;_Tp&gt; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat.html#a4f7803d5c41eef808081903167d3a263">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a4f7803d5c41eef808081903167d3a263">cv::SparseMat</a>.</p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a7de4c57f754bb368c85152c1909cb65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7de4c57f754bb368c85152c1909cb65ba14d02d4adbcb5fa71d1922ceda241e8a"></a>MAGIC_VAL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7de4c57f754bb368c85152c1909cb65babe1aff4cd2b540afd5a3f4ffca3bd9a2"></a>MAX_DIM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7de4c57f754bb368c85152c1909cb65ba28ca477c8ed1afabd0da753827149eeb"></a>HASH_SCALE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7de4c57f754bb368c85152c1909cb65ba79cfd2c6ddc2c192623e8426429d27d1"></a>HASH_BIT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a359e83f7b4372d439ad31a84e72cd12d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the default constructor </p>

</div>
</div>
<a class="anchor" id="adb611458d46e670dcaf099f1fceddf9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the full constructor equivelent to SparseMat(dims, _sizes, DataType&lt;_Tp&gt;::type) </p>

</div>
</div>
<a class="anchor" id="ab0e9b029a622c637e17f8288d968f25c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the copy constructor. If DataType&lt;_Tp&gt;.type != m.type(), the m elements are converted </p>

</div>
</div>
<a class="anchor" id="a773ae7065a51b5440d0d9c8b87b7eba3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the copy constructor. This is O(1) operation - no data is copied </p>

</div>
</div>
<a class="anchor" id="a0938540b46ceeca038f396f019b1e3c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts dense matrix to the sparse form </p>

</div>
</div>
<a class="anchor" id="aadc604a842e482ee41b4d345b4c6504e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts the old-style sparse matrix to the C++ class. All the elements are copied </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0228e94614401ca21c6fe62dccc47365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a>&lt; _Tp &gt; &amp; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the assignment operator. If DataType&lt;_Tp&gt;.type != m.type(), the m elements are converted </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#ab80c24b3713add05c507ff56b3350ca2">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="ac2f76c0259e2b23e8ae0837c6a328331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a>&lt; _Tp &gt; &amp; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the assignment operator. This is O(1) operation - no data is copied </p>

</div>
</div>
<a class="anchor" id="ae0a7d2ef10e45df805c4f77fc7e80487"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a>&lt; _Tp &gt; &amp; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts dense matrix to the sparse form </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a0ddfb53cd5f03f1b262d0f3c7b951f6d">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a1088d4110a7fcbdd08cd962b39dd4e5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">SparseMat_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a1088d4110a7fcbdd08cd962b39dd4e5c">clone</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>makes full copy of the matrix. All the elements are duplicated </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a4c990be3ea562ab9f40c40edaf773a5d">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a18a20736ff3a669e99e041d1c4fa7110"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a18a20736ff3a669e99e041d1c4fa7110">create</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to cv::SparseMat::create(dims, _sizes, DataType&lt;_Tp&gt;::type) </p>

</div>
</div>
<a class="anchor" id="ab7877c4f9221ec11652d357d0a402d67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::operator <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a> * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts sparse matrix to the old-style <a class="el" href="struct_cv_sparse_mat.html">CvSparseMat</a>. All the elements are copied </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a3b522e2f57e588c0f7cb4d3a3b69e8e4">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a3cc1d8257f320f9843b8fcd23b087068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a3cc1d8257f320f9843b8fcd23b087068">type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns type of the matrix elements </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a2611b9eb569ba46ea7013f17c22bfbf8">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a32c205016a6771a833ea2210a666c02a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a32c205016a6771a833ea2210a666c02a">depth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns depth of the matrix elements </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a693e497e5384674c269d415e845dd74a">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="aacc93a364ef5fb74b6db5945440e7cf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#aacc93a364ef5fb74b6db5945440e7cf2">channels</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the number of channels in each matrix element </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#ad0c723bd46ceee0a6c88299fffa7a8b9">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a56d3ce739aecb0474616d5a7e74b50ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a56d3ce739aecb0474616d5a7e74b50ed">ref</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to SparseMat::ref&lt;_Tp&gt;(i0, hashval) </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a925b05f8347aaf82ec037fd823bb2a0e">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="add15b560c15b6e2c6364d4a8608451ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a56d3ce739aecb0474616d5a7e74b50ed">ref</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to SparseMat::ref&lt;_Tp&gt;(i0, i1, hashval) </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#aa027e36635c11e7b59fbf1f64a0d4798">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="ac40f0bddc8f4f66701f57f0f63d249af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a56d3ce739aecb0474616d5a7e74b50ed">ref</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to SparseMat::ref&lt;_Tp&gt;(i0, i1, i2, hashval) </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a533ec9897d2d9d1a151d07a05cced109">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a89fdd145e3a1f0baf354063bf3b21326"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a56d3ce739aecb0474616d5a7e74b50ed">ref</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to SparseMat::ref&lt;_Tp&gt;(idx, hashval) </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a4e7feaec46317e5dae1d2de5c3aa9c18">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a77b48da371733121726faf1912499795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to SparseMat::value&lt;_Tp&gt;(i0, hashval) </p>

</div>
</div>
<a class="anchor" id="a4b77893d6317a9cb708638999037cb2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to SparseMat::value&lt;_Tp&gt;(i0, i1, hashval) </p>

</div>
</div>
<a class="anchor" id="a783ca400b585d995331b7c0ecc658cf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to SparseMat::value&lt;_Tp&gt;(i0, i1, i2, hashval) </p>

</div>
</div>
<a class="anchor" id="a22387ba6aa8ce9cd59246775e1dffe2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>equivalent to SparseMat::value&lt;_Tp&gt;(idx, hashval) </p>

</div>
</div>
<a class="anchor" id="a63186dc2e14f7f06c4a9d08ffd66b604"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a63186dc2e14f7f06c4a9d08ffd66b604">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns sparse matrix iterator pointing to the first sparse matrix element </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a45125aae0952d6b9777be600a8955a06">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a088f5e1c127e37274d2617802035a0a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a63186dc2e14f7f06c4a9d08ffd66b604">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns read-only sparse matrix iterator pointing to the first sparse matrix element </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#ae70ca8ec2bf3945f832870ab7296c536">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a1d72b84fbcf318872bb8a497581ffbf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_iterator__.html">SparseMatIterator_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a1d72b84fbcf318872bb8a497581ffbf8">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns sparse matrix iterator pointing to the element following the last sparse matrix element </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#af5f0a657ed8469a56236df5082bbb78e">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a6d2dd53fde36d82424df7038f249c06f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_sparse_mat_const_iterator__.html">SparseMatConstIterator_</a>&lt; _Tp &gt; <a class="el" href="classcv_1_1_sparse_mat__.html">cv::SparseMat_</a>&lt; _Tp &gt;::<a class="el" href="classcv_1_1_sparse_mat__.html#a1d72b84fbcf318872bb8a497581ffbf8">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns read-only sparse matrix iterator pointing to the element following the last sparse matrix element </p>

<p>Reimplemented from <a class="el" href="classcv_1_1_sparse_mat.html#a1d3e2e9de51dfa3a519e9489876eee7b">cv::SparseMat</a>.</p>

</div>
</div>
<a class="anchor" id="a93c268b7c58435d8ecc3577f439283ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a93c268b7c58435d8ecc3577f439283ee">cv::SparseMat::copyTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copies all the data to the destination matrix. All the previous content of m is erased </p>

</div>
</div>
<a class="anchor" id="adb6344cbc400408f30300dd1a0112da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a93c268b7c58435d8ecc3577f439283ee">cv::SparseMat::copyTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts sparse matrix to dense matrix. </p>

</div>
</div>
<a class="anchor" id="a6ad5f495abf7eedede64afa7203b6b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a6ad5f495abf7eedede64afa7203b6b78">cv::SparseMat::convertTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type </p>

</div>
</div>
<a class="anchor" id="ac631bd31ae1ce1944ba6775f2ce121be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a6ad5f495abf7eedede64afa7203b6b78">cv::SparseMat::convertTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts sparse matrix to dense n-dim matrix with optional type conversion and scaling. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rtype</td><td>The output matrix data type. When it is =-1, the output array will have the same data type as (*this) </td></tr>
    <tr><td class="paramname">alpha</td><td>The scale factor </td></tr>
    <tr><td class="paramname">beta</td><td>The optional delta added to the scaled values before the conversion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dfa0e1a634f76787997a495dd4bdbf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a0dfa0e1a634f76787997a495dd4bdbf0">cv::SparseMat::assignTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_sparse_mat.html">SparseMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adf2713a5ec1fb025c9ff4014a53e68c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#adf2713a5ec1fb025c9ff4014a53e68c6">cv::SparseMat::create</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>reallocates sparse matrix. </p>
<p>If the matrix already had the proper size and type, it is simply cleared with <a class="el" href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e" title="sets all the sparse matrix elements to 0, which means clearing the hash table.">clear()</a>, otherwise, the old matrix is released (using <a class="el" href="classcv_1_1_sparse_mat.html#a3f4c162afd8cc809d23bd0fe9b38ead7">release()</a>) and the new one is allocated. </p>

</div>
</div>
<a class="anchor" id="a2fa705d84961513f6e0b0066ec245a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a2fa705d84961513f6e0b0066ec245a8e">cv::SparseMat::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sets all the sparse matrix elements to 0, which means clearing the hash table. </p>

</div>
</div>
<a class="anchor" id="a8d1d03d3c19ccd8cd5653b3b7375bb68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a8d1d03d3c19ccd8cd5653b3b7375bb68">cv::SparseMat::addref</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>manually increments the reference counter to the header. </p>

</div>
</div>
<a class="anchor" id="a3f4c162afd8cc809d23bd0fe9b38ead7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a3f4c162afd8cc809d23bd0fe9b38ead7">cv::SparseMat::release</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a00f7940230adaaad7bc231016c646f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#a00f7940230adaaad7bc231016c646f1e">cv::SparseMat::elemSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the size of each element in bytes (not including the overhead - the space occupied by <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html" title="sparse matrix node - element of a hash table">SparseMat::Node</a> elements) </p>

</div>
</div>
<a class="anchor" id="abe50d2428ea7bdc8fb74b48248036dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#abe50d2428ea7bdc8fb74b48248036dc6">cv::SparseMat::elemSize1</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns <a class="el" href="classcv_1_1_sparse_mat.html#a00f7940230adaaad7bc231016c646f1e" title="returns the size of each element in bytes (not including the overhead - the space occupied by SparseM...">elemSize()</a>/channels() </p>

</div>
</div>
<a class="anchor" id="a8257efe5b5a93b90da0daf89171012df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int * <a class="el" href="classcv_1_1_sparse_mat.html#a8257efe5b5a93b90da0daf89171012df">cv::SparseMat::size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the array of sizes, or NULL if the matrix is not allocated </p>

</div>
</div>
<a class="anchor" id="af4bd8427b4673af70a6eeeb4559c419a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#a8257efe5b5a93b90da0daf89171012df">cv::SparseMat::size</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the size of i-th matrix dimension (or 0) </p>

</div>
</div>
<a class="anchor" id="a3ff274ef6039cd6db69f156dcbb4ab93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#a3ff274ef6039cd6db69f156dcbb4ab93">cv::SparseMat::dims</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the matrix dimensionality </p>

</div>
</div>
<a class="anchor" id="ab89d7c867e110b49316c6eb2d5d69f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ab89d7c867e110b49316c6eb2d5d69f85">cv::SparseMat::nzcount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the number of non-zero elements (=the number of hash table nodes) </p>

</div>
</div>
<a class="anchor" id="ac28efc048ec9585e0febb830d203fe8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">cv::SparseMat::hash</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes the element hash value (1D case) </p>

</div>
</div>
<a class="anchor" id="aa6f502942ecfb926d2a8879bd9dbc8a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">cv::SparseMat::hash</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes the element hash value (2D case) </p>

</div>
</div>
<a class="anchor" id="aba7d44641efd3c8de7b2bfbff023b384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">cv::SparseMat::hash</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes the element hash value (3D case) </p>

</div>
</div>
<a class="anchor" id="ac83549f5a561022195e387022ee9b06c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcv_1_1_sparse_mat.html#ac28efc048ec9585e0febb830d203fe8b">cv::SparseMat::hash</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes the element hash value (nD case) </p>

</div>
</div>
<a class="anchor" id="a810b96cf23e3cc816e7f99473b81b513"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">cv::SparseMat::ptr</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case. </p>
<p>return pointer to the matrix element. </p>
<ul>
<li>
if the element is there (it's non-zero), the pointer to it is returned </li>
<li>
if it's not there and createMissing=false, NULL pointer is returned </li>
<li>
if it's not there and createMissing=true, then the new element is created and initialized with 0. Pointer to it is returned </li>
<li>
if the optional hashval pointer is not NULL, the element hash value is not computed, but *hashval is taken instead. </li>
</ul>
<p>returns pointer to the specified element (1D case) </p>

</div>
</div>
<a class="anchor" id="a14e7bb6106e6b4608ddbbc394bbf585e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">cv::SparseMat::ptr</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (2D case) </p>

</div>
</div>
<a class="anchor" id="afa0e9b6331a781f1d746e77582bee8a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">cv::SparseMat::ptr</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (3D case) </p>

</div>
</div>
<a class="anchor" id="a5425bac965f62767f50c7e68a7c452a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a810b96cf23e3cc816e7f99473b81b513">cv::SparseMat::ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createMissing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (nD case) </p>

</div>
</div>
<a class="anchor" id="a25af0320f3323181aeb16eae3a2cca55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return value of the specified sparse matrix element. </p>
<div class="fragment"><pre class="fragment">value&lt;_Tp&gt;(i0,...[,hashval]) is equivalent</pre></div> <div class="fragment"><pre class="fragment">     { <span class="keyword">const</span> _Tp* p = find&lt;_Tp&gt;(i0,...[,hashval]); <span class="keywordflow">return</span> p ? *p : _Tp(); }
</pre></div><p>That is, if the element did not exist, the methods return 0. returns value of the specified element (1D case) </p>

</div>
</div>
<a class="anchor" id="a0d254b1881f2a92080c34590034e48bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns value of the specified element (2D case) </p>

</div>
</div>
<a class="anchor" id="a288c58847a9cc310940f0f76f3dfce53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns value of the specified element (3D case) </p>

</div>
</div>
<a class="anchor" id="a948563f1181b81c52b7a600538fa9657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns value of the specified element (nD case) </p>

</div>
</div>
<a class="anchor" id="afe08b740792d6e7f31706616685b70f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the value stored in the sparse martix node </p>

</div>
</div>
<a class="anchor" id="a18d86c436d847195806cf3c1dd07751f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; <a class="el" href="classcv_1_1_sparse_mat.html#a25af0320f3323181aeb16eae3a2cca55">cv::SparseMat::value</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the value stored in the sparse martix node </p>

</div>
</div>
<a class="anchor" id="a46196f5a4b345c43a6ee344d4daee171"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">cv::SparseMat::find</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return pointer to the specified sparse matrix element if it exists. </p>
<p>find&lt;_Tp&gt;(i0,...[,hashval]) is equivalent to (_const Tp*)ptr(i0,...false[,hashval]).</p>
<p>If the specified element does not exist, the methods return NULL. returns pointer to the specified element (1D case) </p>

</div>
</div>
<a class="anchor" id="af5166def1d0ee208e61c13194d736c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">cv::SparseMat::find</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (2D case) </p>

</div>
</div>
<a class="anchor" id="a76f091d90c610bc7c62404a5115fdd2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">cv::SparseMat::find</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (3D case) </p>

</div>
</div>
<a class="anchor" id="a01119d63e21697f1691b16cc1a00628a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * <a class="el" href="classcv_1_1_sparse_mat.html#a46196f5a4b345c43a6ee344d4daee171">cv::SparseMat::find</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the specified element (nD case) </p>

</div>
</div>
<a class="anchor" id="ad4ff041a2a3771613847b94c761ab1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">cv::SparseMat::erase</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>erases the specified element (2D case) </p>

</div>
</div>
<a class="anchor" id="ab00d2c0c7bff3c631d1ac43fe1be45cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">cv::SparseMat::erase</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>erases the specified element (3D case) </p>

</div>
</div>
<a class="anchor" id="a6f64485a3f47ba79847a3fdf349b9943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#ad4ff041a2a3771613847b94c761ab1f4">cv::SparseMat::erase</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hashval</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>erases the specified element (nD case) </p>

</div>
</div>
<a class="anchor" id="a6255da02af3f6d71c2d4dfcc9b94a524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">SparseMat::Node</a> * <a class="el" href="classcv_1_1_sparse_mat.html#a6255da02af3f6d71c2d4dfcc9b94a524">cv::SparseMat::node</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nidx</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac384b30f4c291e6a2526c69dc3de0c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcv_1_1_sparse_mat_1_1_node.html">SparseMat::Node</a> * <a class="el" href="classcv_1_1_sparse_mat.html#a6255da02af3f6d71c2d4dfcc9b94a524">cv::SparseMat::node</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nidx</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acfbf3c27ab6d5f90e4d37b1654f90f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_sparse_mat.html#acfbf3c27ab6d5f90e4d37b1654f90f0a">cv::SparseMat::newNode</a> </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hashval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5adcb69ee679da35f74ea3a78594a692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#a5adcb69ee679da35f74ea3a78594a692">cv::SparseMat::removeNode</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>previdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af86523883daef3f618a7ec38fe049edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="background__segm_8hpp.html#a8bb47f092d473522721002c86c13b94e">void</a> <a class="el" href="classcv_1_1_sparse_mat.html#af86523883daef3f618a7ec38fe049edc">cv::SparseMat::resizeHashTab</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad5f261bc8c1330e4e516684861410cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_sparse_mat.html#ad5f261bc8c1330e4e516684861410cd2">cv::SparseMat::flags</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3741ff43acd46b31aace23dee092d85a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_sparse_mat_1_1_hdr.html">Hdr</a>* <a class="el" href="classcv_1_1_sparse_mat.html#a3741ff43acd46b31aace23dee092d85a">cv::SparseMat::hdr</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/opencv2/core/<a class="el" href="core_8hpp_source.html">core.hpp</a></li>
<li>include/opencv2/core/<a class="el" href="mat_8hpp_source.html">mat.hpp</a></li>
</ul>
</div><!-- contents -->
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>
