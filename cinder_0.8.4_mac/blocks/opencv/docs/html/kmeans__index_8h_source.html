<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">include/opencv2/flann/kmeans_index.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="kmeans__index_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***********************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> * Software License Agreement (BSD License)</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright 2008-2009  Marius Muja (mariusm@cs.ubc.ca). All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright 2008-2009  David G. Lowe (lowe@cs.ubc.ca). All rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * THE BSD LICENSE</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00010"></a>00010 <span class="comment"> * modification, are permitted provided that the following conditions</span>
<a name="l00011"></a>00011 <span class="comment"> * are met:</span>
<a name="l00012"></a>00012 <span class="comment"> *</span>
<a name="l00013"></a>00013 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<a name="l00014"></a>00014 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
<a name="l00015"></a>00015 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00016"></a>00016 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
<a name="l00017"></a>00017 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR</span>
<a name="l00020"></a>00020 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<a name="l00021"></a>00021 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00022"></a>00022 <span class="comment"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00023"></a>00023 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<a name="l00024"></a>00024 <span class="comment"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00025"></a>00025 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00026"></a>00026 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00027"></a>00027 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a name="l00028"></a>00028 <span class="comment"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment"> *************************************************************************/</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#ifndef _OPENCV_KMEANSTREE_H_</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#define _OPENCV_KMEANSTREE_H_</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="general_8h.html">opencv2/flann/general.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="nn__index_8h.html">opencv2/flann/nn_index.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="matrix_8h.html">opencv2/flann/matrix.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="result__set_8h.html">opencv2/flann/result_set.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="heap_8h.html">opencv2/flann/heap.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="allocator_8h.html">opencv2/flann/allocator.h</a>&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="random_8h.html">opencv2/flann/random.h</a>&quot;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">namespace </span>cvflann
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052 
<a name="l00053"></a><a class="code" href="structcvflann_1_1_k_means_index_params.html">00053</a> <span class="keyword">struct </span>CV_EXPORTS <a class="code" href="structcvflann_1_1_k_means_index_params.html">KMeansIndexParams</a> : <span class="keyword">public</span> <a class="code" href="structcvflann_1_1_index_params.html">IndexParams</a> {
<a name="l00054"></a><a class="code" href="structcvflann_1_1_k_means_index_params.html#a874b1e67e4d0758b8109409e77038ee7">00054</a>     <a class="code" href="structcvflann_1_1_k_means_index_params.html">KMeansIndexParams</a>(<span class="keywordtype">int</span> branching_ = 32, <span class="keywordtype">int</span> iterations_ = 11,
<a name="l00055"></a>00055             <a class="code" href="namespacecvflann.html#a0ad8b53e8b203599f13d67e54c197703">flann_centers_init_t</a> centers_init_ = <a class="code" href="namespacecvflann.html#a0ad8b53e8b203599f13d67e54c197703a2cec6d6a56fac53c140b2f8f28a14aef">FLANN_CENTERS_RANDOM</a>, <span class="keywordtype">float</span> cb_index_ = 0.2 ) :
<a name="l00056"></a>00056         <a class="code" href="structcvflann_1_1_index_params.html">IndexParams</a>(<a class="code" href="namespacecvflann.html#a4e3e6c98d774ea77fd7f0045c9bc7817a8f59fc67e6deef84edfaf55506bb8466">FLANN_INDEX_KMEANS</a>),
<a name="l00057"></a>00057         branching(branching_),
<a name="l00058"></a>00058         <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a>(iterations_),
<a name="l00059"></a>00059         centers_init(centers_init_),
<a name="l00060"></a><a class="code" href="structcvflann_1_1_k_means_index_params.html#aee3663b3ad454707a819f622587129d1">00060</a>         cb_index(cb_index_) {};
<a name="l00061"></a>00061 
<a name="l00062"></a>00062     <span class="keywordtype">int</span> branching;             <span class="comment">// branching factor (for kmeans tree)</span>
<a name="l00063"></a><a class="code" href="structcvflann_1_1_k_means_index_params.html#a1936e39b04fbee5fcf2624e9cf225205">00063</a>     <span class="keywordtype">int</span> <a class="code" href="structcvflann_1_1_k_means_index_params.html#a1936e39b04fbee5fcf2624e9cf225205">iterations</a>;            <span class="comment">// max iterations to perform in one kmeans clustering (kmeans tree)</span>
<a name="l00064"></a><a class="code" href="structcvflann_1_1_k_means_index_params.html#ae177ebc9ed1801477c12630860e7a862">00064</a>     <a class="code" href="namespacecvflann.html#a0ad8b53e8b203599f13d67e54c197703">flann_centers_init_t</a> <a class="code" href="structcvflann_1_1_k_means_index_params.html#ae177ebc9ed1801477c12630860e7a862">centers_init</a>;          <span class="comment">// algorithm used for picking the initial cluster centers for kmeans tree</span>
<a name="l00065"></a><a class="code" href="structcvflann_1_1_k_means_index_params.html#af1c9377022c7f8e6235b8e8accf5f38c">00065</a>     <span class="keywordtype">float</span> <a class="code" href="structcvflann_1_1_k_means_index_params.html#af1c9377022c7f8e6235b8e8accf5f38c">cb_index</a>;            <span class="comment">// cluster boundary index. Used when searching the kmeans tree</span>
<a name="l00066"></a>00066 
<a name="l00067"></a><a class="code" href="structcvflann_1_1_k_means_index_params.html#a3ba54a9d8f8fd4ffeec3c8ae3110db51">00067</a>     <span class="keywordtype">void</span> print()<span class="keyword"> const</span>
<a name="l00068"></a>00068 <span class="keyword">    </span>{
<a name="l00069"></a>00069         <a class="code" href="namespacecvflann.html#aefa2fecdfb5b97a4cb066b6f54263386">logger</a>().<a class="code" href="classcvflann_1_1_logger.html#a2ea962f1e4b655d1e02ee747262545ad">info</a>(<span class="stringliteral">&quot;Index type: %d\n&quot;</span>,(<span class="keywordtype">int</span>)algorithm);
<a name="l00070"></a>00070         <a class="code" href="namespacecvflann.html#aefa2fecdfb5b97a4cb066b6f54263386">logger</a>().<a class="code" href="classcvflann_1_1_logger.html#a2ea962f1e4b655d1e02ee747262545ad">info</a>(<span class="stringliteral">&quot;Branching: %d\n&quot;</span>, branching);
<a name="l00071"></a>00071         <a class="code" href="namespacecvflann.html#aefa2fecdfb5b97a4cb066b6f54263386">logger</a>().<a class="code" href="classcvflann_1_1_logger.html#a2ea962f1e4b655d1e02ee747262545ad">info</a>(<span class="stringliteral">&quot;Iterations: %d\n&quot;</span>, <a class="code" href="tracking_8hpp.html#a17372ac3c8ba01bc6cfc265b2824992e">iterations</a>);
<a name="l00072"></a>00072         <a class="code" href="namespacecvflann.html#aefa2fecdfb5b97a4cb066b6f54263386">logger</a>().<a class="code" href="classcvflann_1_1_logger.html#a2ea962f1e4b655d1e02ee747262545ad">info</a>(<span class="stringliteral">&quot;Centres initialisation: %d\n&quot;</span>, centers_init);
<a name="l00073"></a>00073         <a class="code" href="namespacecvflann.html#aefa2fecdfb5b97a4cb066b6f54263386">logger</a>().<a class="code" href="classcvflann_1_1_logger.html#a2ea962f1e4b655d1e02ee747262545ad">info</a>(<span class="stringliteral">&quot;Cluster boundary weight: %g\n&quot;</span>, cb_index);
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 };
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 
<a name="l00085"></a>00085 <a class="code" href="core__c_8h.html#a8bc957583d2a5247e490ea9ce960cf21">template &lt;typename ELEM_TYPE, typename DIST_TYPE = typename DistType&lt;ELEM_TYPE&gt;::type</a> &gt;
<a name="l00086"></a><a class="code" href="classcvflann_1_1_k_means_index.html">00086</a> <span class="keyword">class </span><a class="code" href="classcvflann_1_1_k_means_index.html">KMeansIndex</a> : <span class="keyword">public</span> <a class="code" href="classcvflann_1_1_n_n_index.html">NNIndex</a>&lt;ELEM_TYPE&gt;
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088 
<a name="l00092"></a>00092     <span class="keywordtype">int</span> branching;
<a name="l00093"></a>00093 
<a name="l00098"></a>00098     <span class="keywordtype">int</span> max_iter;
<a name="l00099"></a>00099 
<a name="l00106"></a>00106     <span class="keywordtype">float</span> cb_index;
<a name="l00107"></a>00107 
<a name="l00111"></a>00111     <span class="keyword">const</span> <a class="code" href="classcvflann_1_1_matrix.html">Matrix&lt;ELEM_TYPE&gt;</a> dataset;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="keyword">const</span> <a class="code" href="structcvflann_1_1_index_params.html">IndexParams</a>&amp; index_params;
<a name="l00114"></a>00114 
<a name="l00118"></a>00118     <span class="keywordtype">size_t</span> size_;
<a name="l00119"></a>00119 
<a name="l00123"></a>00123     <span class="keywordtype">size_t</span> veclen_;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 
<a name="l00129"></a>00129     <span class="keyword">struct </span>KMeansNodeSt {
<a name="l00133"></a>00133         DIST_TYPE* pivot;
<a name="l00137"></a>00137         DIST_TYPE <a class="code" href="core__c_8h.html#a7bea932e1cd0c79d103a7870a1921a4e">radius</a>;
<a name="l00141"></a>00141         DIST_TYPE mean_radius;
<a name="l00145"></a>00145         DIST_TYPE variance;
<a name="l00149"></a>00149         <span class="keywordtype">int</span> <a class="code" href="classcvflann_1_1_k_means_index.html#a359639226dd77445fdd94279b6827066">size</a>;
<a name="l00153"></a>00153         KMeansNodeSt** childs;
<a name="l00157"></a>00157         <span class="keywordtype">int</span>* <a class="code" href="imgproc__c_8h.html#a3e3b9b48bcbc7f460efbcfe4399ad24a">indices</a>;
<a name="l00161"></a>00161         <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#ac693e272fb1883fe0343f55a14d72b22">level</a>;
<a name="l00162"></a>00162     };
<a name="l00163"></a>00163     <span class="keyword">typedef</span> KMeansNodeSt* KMeansNode;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 
<a name="l00170"></a>00170     <span class="keyword">typedef</span> <a class="code" href="structcvflann_1_1_branch_struct.html">BranchStruct&lt;KMeansNode&gt;</a> <a class="code" href="structcvflann_1_1_branch_struct.html">BranchSt</a>;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 
<a name="l00176"></a>00176     KMeansNode root;
<a name="l00177"></a>00177 
<a name="l00181"></a>00181     <span class="keywordtype">int</span>* indices;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 
<a name="l00191"></a>00191     <a class="code" href="classcvflann_1_1_pooled_allocator.html">PooledAllocator</a> pool;
<a name="l00192"></a>00192 
<a name="l00196"></a>00196     <span class="keywordtype">int</span> memoryCounter;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     <span class="keyword">typedef</span> <a class="code" href="highgui__c_8h.html#ad1f9461adaad33556b3a01c7f2c6ceab">void</a> (<a class="code" href="classcvflann_1_1_k_means_index.html">KMeansIndex</a>::*centersAlgFunction)(int, <span class="keywordtype">int</span>*, int, <span class="keywordtype">int</span>*, <span class="keywordtype">int</span>&amp;);
<a name="l00200"></a>00200 
<a name="l00204"></a>00204     centersAlgFunction chooseCenters;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 
<a name="l00218"></a>00218     <span class="keywordtype">void</span> chooseCentersRandom(<span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>, <span class="keywordtype">int</span>* indices, <span class="keywordtype">int</span> indices_length, <span class="keywordtype">int</span>* centers, <span class="keywordtype">int</span>&amp; centers_length)
<a name="l00219"></a>00219     {
<a name="l00220"></a>00220         <a class="code" href="classcvflann_1_1_unique_random.html">UniqueRandom</a> <a class="code" href="core__c_8h.html#a54709f3b06b33b66763f1613cc7fb571">r</a>(indices_length);
<a name="l00221"></a>00221 
<a name="l00222"></a>00222         <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;
<a name="l00223"></a>00223         <span class="keywordflow">for</span> (index=0;index&lt;<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>;++<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>) {
<a name="l00224"></a>00224             <span class="keywordtype">bool</span> duplicate = <span class="keyword">true</span>;
<a name="l00225"></a>00225             <span class="keywordtype">int</span> rnd;
<a name="l00226"></a>00226             <span class="keywordflow">while</span> (duplicate) {
<a name="l00227"></a>00227                 duplicate = <span class="keyword">false</span>;
<a name="l00228"></a>00228                 rnd = r.<a class="code" href="classcvflann_1_1_unique_random.html#a95eb32308d0a5a2d99a03fe23d809c1f">next</a>();
<a name="l00229"></a>00229                 <span class="keywordflow">if</span> (rnd&lt;0) {
<a name="l00230"></a>00230                     centers_length = <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;
<a name="l00231"></a>00231                     <span class="keywordflow">return</span>;
<a name="l00232"></a>00232                 }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234                 centers[<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>] = indices[rnd];
<a name="l00235"></a>00235 
<a name="l00236"></a>00236                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;++j) {
<a name="l00237"></a>00237                     <span class="keywordtype">float</span> sq = (float)flann_dist(dataset[centers[index]],dataset[centers[index]]+dataset.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>,dataset[centers[j]]);
<a name="l00238"></a>00238                     <span class="keywordflow">if</span> (sq&lt;1e-16) {
<a name="l00239"></a>00239                         duplicate = <span class="keyword">true</span>;
<a name="l00240"></a>00240                     }
<a name="l00241"></a>00241                 }
<a name="l00242"></a>00242             }
<a name="l00243"></a>00243         }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         centers_length = <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 
<a name="l00259"></a>00259     <span class="keywordtype">void</span> chooseCentersGonzales(<span class="keywordtype">int</span> k, <span class="keywordtype">int</span>* indices, <span class="keywordtype">int</span> indices_length, <span class="keywordtype">int</span>* centers, <span class="keywordtype">int</span>&amp; centers_length)
<a name="l00260"></a>00260     {
<a name="l00261"></a>00261         <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> = indices_length;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263         <span class="keywordtype">int</span> rnd = <a class="code" href="namespacecvflann.html#a2c558b7133e1ecf74abd46c3488226aa">rand_int</a>(n);
<a name="l00264"></a>00264         assert(rnd &gt;=0 &amp;&amp; rnd &lt; n);
<a name="l00265"></a>00265 
<a name="l00266"></a>00266         centers[0] = indices[rnd];
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;
<a name="l00269"></a>00269         <span class="keywordflow">for</span> (index=1; index&lt;<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>; ++<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>) {
<a name="l00270"></a>00270 
<a name="l00271"></a>00271             <span class="keywordtype">int</span> best_index = -1;
<a name="l00272"></a>00272             <span class="keywordtype">float</span> best_val = 0;
<a name="l00273"></a>00273             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;<a class="code" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>;++j) {
<a name="l00274"></a>00274                 <span class="keywordtype">float</span> <a class="code" href="imgproc__c_8h.html#a5ff9213baa788fe8470a05e0b2b8cdb8">dist</a> = (float)flann_dist(dataset[centers[0]],dataset[centers[0]]+dataset.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>,dataset[indices[j]]);
<a name="l00275"></a>00275                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1;i&lt;<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;++i) {
<a name="l00276"></a>00276                         <span class="keywordtype">float</span> tmp_dist = (float)flann_dist(dataset[centers[i]],dataset[centers[i]]+dataset.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>,dataset[indices[j]]);
<a name="l00277"></a>00277                     <span class="keywordflow">if</span> (tmp_dist&lt;dist) {
<a name="l00278"></a>00278                         dist = tmp_dist;
<a name="l00279"></a>00279                     }
<a name="l00280"></a>00280                 }
<a name="l00281"></a>00281                 <span class="keywordflow">if</span> (dist&gt;best_val) {
<a name="l00282"></a>00282                     best_val = <a class="code" href="imgproc__c_8h.html#a5ff9213baa788fe8470a05e0b2b8cdb8">dist</a>;
<a name="l00283"></a>00283                     best_index = j;
<a name="l00284"></a>00284                 }
<a name="l00285"></a>00285             }
<a name="l00286"></a>00286             <span class="keywordflow">if</span> (best_index!=-1) {
<a name="l00287"></a>00287                 centers[<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>] = indices[best_index];
<a name="l00288"></a>00288             }
<a name="l00289"></a>00289             <span class="keywordflow">else</span> {
<a name="l00290"></a>00290                 <span class="keywordflow">break</span>;
<a name="l00291"></a>00291             }
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293         centers_length = <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 
<a name="l00310"></a>00310     <span class="keywordtype">void</span> chooseCentersKMeanspp(<span class="keywordtype">int</span> k, <span class="keywordtype">int</span>* indices, <span class="keywordtype">int</span> indices_length, <span class="keywordtype">int</span>* centers, <span class="keywordtype">int</span>&amp; centers_length)
<a name="l00311"></a>00311     {
<a name="l00312"></a>00312         <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> = indices_length;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         <span class="keywordtype">double</span> currentPot = 0;
<a name="l00315"></a>00315         <span class="keywordtype">double</span>* closestDistSq = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>];
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         <span class="comment">// Choose one random center and set the closestDistSq values</span>
<a name="l00318"></a>00318         <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a> = <a class="code" href="namespacecvflann.html#a2c558b7133e1ecf74abd46c3488226aa">rand_int</a>(n);
<a name="l00319"></a>00319         assert(index &gt;=0 &amp;&amp; index &lt; n);
<a name="l00320"></a>00320         centers[0] = indices[<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>];
<a name="l00321"></a>00321 
<a name="l00322"></a>00322         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>; i++) {
<a name="l00323"></a>00323             closestDistSq[i] = flann_dist(dataset[indices[i]], dataset[indices[i]] + dataset.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>, dataset[indices[index]]);
<a name="l00324"></a>00324             currentPot += closestDistSq[i];
<a name="l00325"></a>00325         }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 
<a name="l00328"></a>00328         <span class="keyword">const</span> <span class="keywordtype">int</span> numLocalTries = 1;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330         <span class="comment">// Choose each center</span>
<a name="l00331"></a>00331         <span class="keywordtype">int</span> centerCount;
<a name="l00332"></a>00332         <span class="keywordflow">for</span> (centerCount = 1; centerCount &lt; <a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>; centerCount++) {
<a name="l00333"></a>00333 
<a name="l00334"></a>00334             <span class="comment">// Repeat several trials</span>
<a name="l00335"></a>00335             <span class="keywordtype">double</span> bestNewPot = -1;
<a name="l00336"></a>00336             <span class="keywordtype">int</span> bestNewIndex = -1;
<a name="l00337"></a>00337             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> localTrial = 0; localTrial &lt; numLocalTries; localTrial++) {
<a name="l00338"></a>00338 
<a name="l00339"></a>00339                 <span class="comment">// Choose our center - have to be slightly careful to return a valid answer even accounting</span>
<a name="l00340"></a>00340                 <span class="comment">// for possible rounding errors</span>
<a name="l00341"></a>00341             <span class="keywordtype">double</span> randVal = <a class="code" href="namespacecvflann.html#afbd0566268e54b93b94748d2cb1d3b89">rand_double</a>(currentPot);
<a name="l00342"></a>00342                 <span class="keywordflow">for</span> (index = 0; index &lt; n-1; index++) {
<a name="l00343"></a>00343                     <span class="keywordflow">if</span> (randVal &lt;= closestDistSq[index])
<a name="l00344"></a>00344                         <span class="keywordflow">break</span>;
<a name="l00345"></a>00345                     <span class="keywordflow">else</span>
<a name="l00346"></a>00346                         randVal -= closestDistSq[<a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>];
<a name="l00347"></a>00347                 }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349                 <span class="comment">// Compute the new potential</span>
<a name="l00350"></a>00350                 <span class="keywordtype">double</span> newPot = 0;
<a name="l00351"></a>00351                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>; i++)
<a name="l00352"></a>00352                     newPot += <a class="code" href="namespacecv.html#ab95fdcad3fb0246321e2af231d24d5a9" title="computes per-element minimum of two arrays (dst = min(src1, src2))">std::min</a>( flann_dist(dataset[indices[i]], dataset[indices[i]] + dataset.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>, dataset[indices[index]]), closestDistSq[i] );
<a name="l00353"></a>00353 
<a name="l00354"></a>00354                 <span class="comment">// Store the best result</span>
<a name="l00355"></a>00355                 <span class="keywordflow">if</span> (bestNewPot &lt; 0 || newPot &lt; bestNewPot) {
<a name="l00356"></a>00356                     bestNewPot = newPot;
<a name="l00357"></a>00357                     bestNewIndex = <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;
<a name="l00358"></a>00358                 }
<a name="l00359"></a>00359             }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361             <span class="comment">// Add the appropriate center</span>
<a name="l00362"></a>00362             centers[centerCount] = indices[bestNewIndex];
<a name="l00363"></a>00363             currentPot = bestNewPot;
<a name="l00364"></a>00364             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="imgproc__c_8h.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>; i++)
<a name="l00365"></a>00365                 closestDistSq[i] = <a class="code" href="namespacecv.html#ab95fdcad3fb0246321e2af231d24d5a9" title="computes per-element minimum of two arrays (dst = min(src1, src2))">std::min</a>( flann_dist(dataset[indices[i]], dataset[indices[i]]+dataset.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>, dataset[indices[bestNewIndex]]), closestDistSq[i] );
<a name="l00366"></a>00366         }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368         centers_length = centerCount;
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         <span class="keyword">delete</span>[] closestDistSq;
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="keyword">public</span>:
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 
<a name="l00378"></a><a class="code" href="classcvflann_1_1_k_means_index.html#aa4755c94898bd21810962eba877236ec">00378</a>     <a class="code" href="namespacecvflann.html#a4e3e6c98d774ea77fd7f0045c9bc7817">flann_algorithm_t</a> <a class="code" href="classcvflann_1_1_k_means_index.html#aa4755c94898bd21810962eba877236ec">getType</a>()<span class="keyword"> const</span>
<a name="l00379"></a>00379 <span class="keyword">    </span>{
<a name="l00380"></a>00380         <span class="keywordflow">return</span> <a class="code" href="namespacecvflann.html#a4e3e6c98d774ea77fd7f0045c9bc7817a8f59fc67e6deef84edfaf55506bb8466">FLANN_INDEX_KMEANS</a>;
<a name="l00381"></a>00381     }
<a name="l00382"></a>00382 
<a name="l00390"></a><a class="code" href="classcvflann_1_1_k_means_index.html#a9cad7cfdf9c2abd17535c300797b92f8">00390</a>     <a class="code" href="classcvflann_1_1_k_means_index.html#a9cad7cfdf9c2abd17535c300797b92f8">KMeansIndex</a>(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_matrix.html">Matrix&lt;ELEM_TYPE&gt;</a>&amp; inputData, <span class="keyword">const</span> <a class="code" href="structcvflann_1_1_k_means_index_params.html">KMeansIndexParams</a>&amp; <a class="code" href="features2d_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a> = <a class="code" href="structcvflann_1_1_k_means_index_params.html">KMeansIndexParams</a>() )
<a name="l00391"></a>00391         : dataset(inputData), index_params(<a class="code" href="features2d_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>), root(NULL), indices(NULL)
<a name="l00392"></a>00392     {
<a name="l00393"></a>00393         memoryCounter = 0;
<a name="l00394"></a>00394 
<a name="l00395"></a>00395         size_ = dataset.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a>;
<a name="l00396"></a>00396         veclen_ = dataset.<a class="code" href="classcvflann_1_1_matrix.html#a37b28f9c0d87c84cf396dcbe90fae71f">cols</a>;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398         branching = <a class="code" href="features2d_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>.branching;
<a name="l00399"></a>00399         max_iter = <a class="code" href="features2d_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>.iterations;
<a name="l00400"></a>00400         <span class="keywordflow">if</span> (max_iter&lt;0) {
<a name="l00401"></a>00401             max_iter = (<a class="code" href="namespacecv.html#a22a8f8afb6090a66a771348b658dcebd" title="computes per-element maximum of two arrays (dst = max(src1, src2))">std::numeric_limits&lt;int&gt;::max</a>)();
<a name="l00402"></a>00402         }
<a name="l00403"></a>00403         <a class="code" href="namespacecvflann.html#a0ad8b53e8b203599f13d67e54c197703">flann_centers_init_t</a> centersInit = <a class="code" href="features2d_8hpp.html#a0480a03ecc41b20cde376602531d9270">params</a>.centers_init;
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         <span class="keywordflow">if</span> (centersInit==<a class="code" href="namespacecvflann.html#a0ad8b53e8b203599f13d67e54c197703a2cec6d6a56fac53c140b2f8f28a14aef">FLANN_CENTERS_RANDOM</a>) {
<a name="l00406"></a>00406             chooseCenters = &amp;KMeansIndex::chooseCentersRandom;
<a name="l00407"></a>00407         }
<a name="l00408"></a>00408         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (centersInit==<a class="code" href="namespacecvflann.html#a0ad8b53e8b203599f13d67e54c197703a8f42551d6005b25200e6e239d7e1f036">FLANN_CENTERS_GONZALES</a>) {
<a name="l00409"></a>00409             chooseCenters = &amp;KMeansIndex::chooseCentersGonzales;
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (centersInit==<a class="code" href="namespacecvflann.html#a0ad8b53e8b203599f13d67e54c197703a99f2e3471f856cda026b4d922275e60b">FLANN_CENTERS_KMEANSPP</a>) {
<a name="l00412"></a>00412                     chooseCenters = &amp;KMeansIndex::chooseCentersKMeanspp;
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414         <span class="keywordflow">else</span> {
<a name="l00415"></a>00415             <span class="keywordflow">throw</span> <a class="code" href="classcvflann_1_1_f_l_a_n_n_exception.html">FLANNException</a>(<span class="stringliteral">&quot;Unknown algorithm for choosing initial centers.&quot;</span>);
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417         cb_index = 0.4f;
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 
<a name="l00427"></a><a class="code" href="classcvflann_1_1_k_means_index.html#a9e6dc62611e010770ee43ce95db43f6a">00427</a>     <span class="keyword">virtual</span> <a class="code" href="classcvflann_1_1_k_means_index.html#a9e6dc62611e010770ee43ce95db43f6a">~KMeansIndex</a>()
<a name="l00428"></a>00428     {
<a name="l00429"></a>00429         <span class="keywordflow">if</span> (root != NULL) {
<a name="l00430"></a>00430             free_centers(root);
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432         <span class="keywordflow">if</span> (indices!=NULL) {
<a name="l00433"></a>00433           <span class="keyword">delete</span>[] indices;
<a name="l00434"></a>00434         }
<a name="l00435"></a>00435     }
<a name="l00436"></a>00436 
<a name="l00440"></a><a class="code" href="classcvflann_1_1_k_means_index.html#a359639226dd77445fdd94279b6827066">00440</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcvflann_1_1_k_means_index.html#a359639226dd77445fdd94279b6827066">size</a>()<span class="keyword"> const</span>
<a name="l00441"></a>00441 <span class="keyword">    </span>{
<a name="l00442"></a>00442         <span class="keywordflow">return</span> size_;
<a name="l00443"></a>00443     }
<a name="l00444"></a>00444 
<a name="l00448"></a><a class="code" href="classcvflann_1_1_k_means_index.html#add8514687fe25395184ca180a4192cde">00448</a>     <span class="keywordtype">size_t</span> <a class="code" href="classcvflann_1_1_k_means_index.html#add8514687fe25395184ca180a4192cde">veclen</a>()<span class="keyword"> const</span>
<a name="l00449"></a>00449 <span class="keyword">    </span>{
<a name="l00450"></a>00450         <span class="keywordflow">return</span> veclen_;
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 
<a name="l00454"></a><a class="code" href="classcvflann_1_1_k_means_index.html#af4e2d790695ffbb09c4644fd719d56e8">00454</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_k_means_index.html#af4e2d790695ffbb09c4644fd719d56e8">set_cb_index</a>( <span class="keywordtype">float</span> <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)
<a name="l00455"></a>00455     {
<a name="l00456"></a>00456         cb_index = <a class="code" href="core__c_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>;
<a name="l00457"></a>00457     }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 
<a name="l00464"></a><a class="code" href="classcvflann_1_1_k_means_index.html#a451ef7a22a1b613357247ffcaa1df47b">00464</a>     <span class="keywordtype">int</span> <a class="code" href="classcvflann_1_1_k_means_index.html#a451ef7a22a1b613357247ffcaa1df47b">usedMemory</a>()<span class="keyword"> const</span>
<a name="l00465"></a>00465 <span class="keyword">    </span>{
<a name="l00466"></a>00466         <span class="keywordflow">return</span>  pool.<a class="code" href="classcvflann_1_1_pooled_allocator.html#a6e5510ec11212e0bb1b109b3af09e172">usedMemory</a>+pool.<a class="code" href="classcvflann_1_1_pooled_allocator.html#af69edd6191138a563f9205d1db7bdd18">wastedMemory</a>+memoryCounter;
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468 
<a name="l00472"></a><a class="code" href="classcvflann_1_1_k_means_index.html#a84d29c52236ab7a1ce68a843df88e86d">00472</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_k_means_index.html#a84d29c52236ab7a1ce68a843df88e86d">buildIndex</a>()
<a name="l00473"></a>00473     {
<a name="l00474"></a>00474         <span class="keywordflow">if</span> (branching&lt;2) {
<a name="l00475"></a>00475             <span class="keywordflow">throw</span> <a class="code" href="classcvflann_1_1_f_l_a_n_n_exception.html">FLANNException</a>(<span class="stringliteral">&quot;Branching factor must be at least 2&quot;</span>);
<a name="l00476"></a>00476         }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         indices = <span class="keyword">new</span> <span class="keywordtype">int</span>[size_];
<a name="l00479"></a>00479         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;size_;++i) {
<a name="l00480"></a>00480             indices[i] = (int)i;
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         root = pool.<a class="code" href="classcvflann_1_1_pooled_allocator.html#aaf127cab57cd0e0f4d3b335efd8d3a67">allocate</a>&lt;KMeansNodeSt&gt;();
<a name="l00484"></a>00484         computeNodeStatistics(root, indices, (<span class="keywordtype">int</span>)size_);
<a name="l00485"></a>00485         computeClustering(root, indices, (<span class="keywordtype">int</span>)size_, branching,0);
<a name="l00486"></a>00486     }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 
<a name="l00489"></a><a class="code" href="classcvflann_1_1_k_means_index.html#ae8776ad3abbba2ad488247c3c67b2b76">00489</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_k_means_index.html#ae8776ad3abbba2ad488247c3c67b2b76">saveIndex</a>(FILE* stream)
<a name="l00490"></a>00490     {
<a name="l00491"></a>00491         <a class="code" href="namespacecvflann.html#a36f2bc5e2fff2d4c609b3672aa5062fd">save_value</a>(stream, branching);
<a name="l00492"></a>00492         <a class="code" href="namespacecvflann.html#a36f2bc5e2fff2d4c609b3672aa5062fd">save_value</a>(stream, max_iter);
<a name="l00493"></a>00493         <a class="code" href="namespacecvflann.html#a36f2bc5e2fff2d4c609b3672aa5062fd">save_value</a>(stream, memoryCounter);
<a name="l00494"></a>00494         <a class="code" href="namespacecvflann.html#a36f2bc5e2fff2d4c609b3672aa5062fd">save_value</a>(stream, cb_index);
<a name="l00495"></a>00495         <a class="code" href="namespacecvflann.html#a36f2bc5e2fff2d4c609b3672aa5062fd">save_value</a>(stream, *indices, (<span class="keywordtype">int</span>)size_);
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         save_tree(stream, root);
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 
<a name="l00501"></a><a class="code" href="classcvflann_1_1_k_means_index.html#a6745c1cdda85e75710bab7490c5248c5">00501</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_k_means_index.html#a6745c1cdda85e75710bab7490c5248c5">loadIndex</a>(FILE* stream)
<a name="l00502"></a>00502     {
<a name="l00503"></a>00503         <a class="code" href="namespacecvflann.html#ad1dc141c7c88a6d1dfdf1cad545f045f">load_value</a>(stream, branching);
<a name="l00504"></a>00504         <a class="code" href="namespacecvflann.html#ad1dc141c7c88a6d1dfdf1cad545f045f">load_value</a>(stream, max_iter);
<a name="l00505"></a>00505         <a class="code" href="namespacecvflann.html#ad1dc141c7c88a6d1dfdf1cad545f045f">load_value</a>(stream, memoryCounter);
<a name="l00506"></a>00506         <a class="code" href="namespacecvflann.html#ad1dc141c7c88a6d1dfdf1cad545f045f">load_value</a>(stream, cb_index);
<a name="l00507"></a>00507         <span class="keywordflow">if</span> (indices!=NULL) {
<a name="l00508"></a>00508             <span class="keyword">delete</span>[] indices;
<a name="l00509"></a>00509         }
<a name="l00510"></a>00510         indices = <span class="keyword">new</span> <span class="keywordtype">int</span>[size_];
<a name="l00511"></a>00511         <a class="code" href="namespacecvflann.html#ad1dc141c7c88a6d1dfdf1cad545f045f">load_value</a>(stream, *indices, (<span class="keywordtype">int</span>)size_);
<a name="l00512"></a>00512 
<a name="l00513"></a>00513         <span class="keywordflow">if</span> (root!=NULL) {
<a name="l00514"></a>00514             free_centers(root);
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516         load_tree(stream, root);
<a name="l00517"></a>00517     }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 
<a name="l00529"></a><a class="code" href="classcvflann_1_1_k_means_index.html#a7ca83d80fe3c987f33b5fd13fdf9a348">00529</a>     <span class="keywordtype">void</span> <a class="code" href="classcvflann_1_1_k_means_index.html#a7ca83d80fe3c987f33b5fd13fdf9a348">findNeighbors</a>(<a class="code" href="classcvflann_1_1_result_set.html">ResultSet&lt;ELEM_TYPE&gt;</a>&amp; <a class="code" href="core__c_8h.html#a14871c176a686a03035b5f2bbc72a63f">result</a>, <span class="keyword">const</span> ELEM_TYPE* vec, <span class="keyword">const</span> <a class="code" href="structcvflann_1_1_search_params.html">SearchParams</a>&amp; searchParams)
<a name="l00530"></a>00530     {
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         <span class="keywordtype">int</span> maxChecks = searchParams.<a class="code" href="structcvflann_1_1_search_params.html#a0595a5111a0a0c4d4378ba05b28465cc">checks</a>;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         <span class="keywordflow">if</span> (maxChecks&lt;0) {
<a name="l00535"></a>00535             findExactNN(root, result, vec);
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537         <span class="keywordflow">else</span> {
<a name="l00538"></a>00538              <span class="comment">// Priority queue storing intermediate branches in the best-bin-first search</span>
<a name="l00539"></a>00539             <a class="code" href="classcvflann_1_1_heap.html">Heap&lt;BranchSt&gt;</a>* heap = <span class="keyword">new</span> <a class="code" href="classcvflann_1_1_heap.html">Heap&lt;BranchSt&gt;</a>((int)size_);
<a name="l00540"></a>00540 
<a name="l00541"></a>00541             <span class="keywordtype">int</span> checks = 0;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543             findNN(root, result, vec, checks, maxChecks, heap);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545             <a class="code" href="structcvflann_1_1_branch_struct.html">BranchSt</a> branch;
<a name="l00546"></a>00546             <span class="keywordflow">while</span> (heap-&gt;<a class="code" href="classcvflann_1_1_heap.html#a6c6d2fd6b7522e13049389ab4ae0e0ab">popMin</a>(branch) &amp;&amp; (checks&lt;maxChecks || !result.<a class="code" href="classcvflann_1_1_result_set.html#a9a0526a2c0afc214be37b0ca2b3eb13d">full</a>())) {
<a name="l00547"></a>00547                 KMeansNode <a class="code" href="core__c_8h.html#a4e145da43d8cadc65b69ce0c2a2cc76a">node</a> = branch.<a class="code" href="structcvflann_1_1_branch_struct.html#a666b372ea6995f6798dff87b1504d969">node</a>;
<a name="l00548"></a>00548                 findNN(node, result, vec, checks, maxChecks, heap);
<a name="l00549"></a>00549             }
<a name="l00550"></a>00550             assert(result.<a class="code" href="classcvflann_1_1_result_set.html#a9a0526a2c0afc214be37b0ca2b3eb13d">full</a>());
<a name="l00551"></a>00551 
<a name="l00552"></a>00552             <span class="keyword">delete</span> heap;
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554 
<a name="l00555"></a>00555     }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 
<a name="l00565"></a><a class="code" href="classcvflann_1_1_k_means_index.html#ae6f9411d474625c7346ef54917d65f4c">00565</a>     <span class="keywordtype">int</span> <a class="code" href="classcvflann_1_1_k_means_index.html#ae6f9411d474625c7346ef54917d65f4c">getClusterCenters</a>(<a class="code" href="classcvflann_1_1_matrix.html">Matrix&lt;DIST_TYPE&gt;</a>&amp; centers)
<a name="l00566"></a>00566     {
<a name="l00567"></a>00567         <span class="keywordtype">int</span> numClusters = centers.<a class="code" href="classcvflann_1_1_matrix.html#aff6ee6abf050b1848fca59654c5669bc">rows</a>;
<a name="l00568"></a>00568         <span class="keywordflow">if</span> (numClusters&lt;1) {
<a name="l00569"></a>00569             <span class="keywordflow">throw</span> <a class="code" href="classcvflann_1_1_f_l_a_n_n_exception.html">FLANNException</a>(<span class="stringliteral">&quot;Number of clusters must be at least 1&quot;</span>);
<a name="l00570"></a>00570         }
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         <span class="keywordtype">float</span> variance;
<a name="l00573"></a>00573         KMeansNode* clusters = <span class="keyword">new</span> KMeansNode[numClusters];
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         <span class="keywordtype">int</span> clusterCount = getMinVarianceClusters(root, clusters, numClusters, variance);
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 <span class="comment">//         logger().info(&quot;Clusters requested: %d, returning %d\n&quot;,numClusters, clusterCount);</span>
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 
<a name="l00580"></a>00580         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;clusterCount;++i) {
<a name="l00581"></a>00581             DIST_TYPE* <a class="code" href="core__c_8h.html#a3f007d4bba0b0e0a4cbcb681f97f241c">center</a> = clusters[i]-&gt;pivot;
<a name="l00582"></a>00582             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;veclen_;++j) {
<a name="l00583"></a>00583                 centers[i][j] = center[j];
<a name="l00584"></a>00584             }
<a name="l00585"></a>00585         }
<a name="l00586"></a>00586         <span class="keyword">delete</span>[] clusters;
<a name="l00587"></a>00587 
<a name="l00588"></a>00588         <span class="keywordflow">return</span> clusterCount;
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590 
<a name="l00591"></a><a class="code" href="classcvflann_1_1_k_means_index.html#a691c1a84cd5f35fd30f4465d6bde8dce">00591</a>     <span class="keyword">const</span> <a class="code" href="structcvflann_1_1_index_params.html">IndexParams</a>* <a class="code" href="classcvflann_1_1_k_means_index.html#a691c1a84cd5f35fd30f4465d6bde8dce">getParameters</a>()<span class="keyword"> const</span>
<a name="l00592"></a>00592 <span class="keyword">    </span>{
<a name="l00593"></a>00593         <span class="keywordflow">return</span> &amp;index_params;
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596 
<a name="l00597"></a>00597 <span class="keyword">private</span>:
<a name="l00598"></a>00598 
<a name="l00599"></a>00599     <a class="code" href="classcvflann_1_1_k_means_index.html">KMeansIndex</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_k_means_index.html">KMeansIndex</a>&amp;);
<a name="l00600"></a>00600     <a class="code" href="classcvflann_1_1_k_means_index.html#a9cad7cfdf9c2abd17535c300797b92f8">KMeansIndex</a>(<span class="keyword">const</span> <a class="code" href="classcvflann_1_1_k_means_index.html">KMeansIndex</a>&amp;);
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     <span class="keywordtype">void</span> save_tree(FILE* stream, KMeansNode <a class="code" href="core__c_8h.html#a4e145da43d8cadc65b69ce0c2a2cc76a">node</a>)
<a name="l00603"></a>00603     {
<a name="l00604"></a>00604         <a class="code" href="namespacecvflann.html#a36f2bc5e2fff2d4c609b3672aa5062fd">save_value</a>(stream, *node);
<a name="l00605"></a>00605         <a class="code" href="namespacecvflann.html#a36f2bc5e2fff2d4c609b3672aa5062fd">save_value</a>(stream, *(node-&gt;pivot), (<span class="keywordtype">int</span>)veclen_);
<a name="l00606"></a>00606         <span class="keywordflow">if</span> (node-&gt;childs==NULL) {
<a name="l00607"></a>00607             <span class="keywordtype">int</span> indices_offset = (int)(node-&gt;indices - indices);
<a name="l00608"></a>00608             <a class="code" href="namespacecvflann.html#a36f2bc5e2fff2d4c609b3672aa5062fd">save_value</a>(stream, indices_offset);
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610         <span class="keywordflow">else</span> {
<a name="l00611"></a>00611             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;branching; ++i) {
<a name="l00612"></a>00612                 save_tree(stream, node-&gt;childs[i]);
<a name="l00613"></a>00613             }
<a name="l00614"></a>00614         }
<a name="l00615"></a>00615     }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 
<a name="l00618"></a>00618     <span class="keywordtype">void</span> load_tree(FILE* stream, KMeansNode&amp; node)
<a name="l00619"></a>00619     {
<a name="l00620"></a>00620         node = pool.<a class="code" href="classcvflann_1_1_pooled_allocator.html#aaf127cab57cd0e0f4d3b335efd8d3a67">allocate</a>&lt;KMeansNodeSt&gt;();
<a name="l00621"></a>00621         <a class="code" href="namespacecvflann.html#ad1dc141c7c88a6d1dfdf1cad545f045f">load_value</a>(stream, *node);
<a name="l00622"></a>00622         node-&gt;pivot = <span class="keyword">new</span> DIST_TYPE[veclen_];
<a name="l00623"></a>00623         <a class="code" href="namespacecvflann.html#ad1dc141c7c88a6d1dfdf1cad545f045f">load_value</a>(stream, *(node-&gt;pivot), (<span class="keywordtype">int</span>)veclen_);
<a name="l00624"></a>00624         <span class="keywordflow">if</span> (node-&gt;childs==NULL) {
<a name="l00625"></a>00625             <span class="keywordtype">int</span> indices_offset;
<a name="l00626"></a>00626             <a class="code" href="namespacecvflann.html#ad1dc141c7c88a6d1dfdf1cad545f045f">load_value</a>(stream, indices_offset);
<a name="l00627"></a>00627             node-&gt;indices = indices + indices_offset;
<a name="l00628"></a>00628         }
<a name="l00629"></a>00629         <span class="keywordflow">else</span> {
<a name="l00630"></a>00630             node-&gt;childs = pool.<a class="code" href="classcvflann_1_1_pooled_allocator.html#aaf127cab57cd0e0f4d3b335efd8d3a67">allocate</a>&lt;KMeansNode&gt;(branching);
<a name="l00631"></a>00631             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;branching; ++i) {
<a name="l00632"></a>00632                 load_tree(stream, node-&gt;childs[i]);
<a name="l00633"></a>00633             }
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635     }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 
<a name="l00641"></a>00641     <span class="keywordtype">void</span> free_centers(KMeansNode node)
<a name="l00642"></a>00642     {
<a name="l00643"></a>00643         <span class="keyword">delete</span>[] node-&gt;pivot;
<a name="l00644"></a>00644         <span class="keywordflow">if</span> (node-&gt;childs!=NULL) {
<a name="l00645"></a>00645             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;branching;++<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>) {
<a name="l00646"></a>00646                 free_centers(node-&gt;childs[k]);
<a name="l00647"></a>00647             }
<a name="l00648"></a>00648         }
<a name="l00649"></a>00649     }
<a name="l00650"></a>00650 
<a name="l00658"></a>00658     <span class="keywordtype">void</span> computeNodeStatistics(KMeansNode node, <span class="keywordtype">int</span>* indices, <span class="keywordtype">int</span> indices_length) {
<a name="l00659"></a>00659 
<a name="l00660"></a>00660         <span class="keywordtype">double</span> <a class="code" href="core__c_8h.html#a7bea932e1cd0c79d103a7870a1921a4e">radius</a> = 0;
<a name="l00661"></a>00661         <span class="keywordtype">double</span> variance = 0;
<a name="l00662"></a>00662         DIST_TYPE* <a class="code" href="core__c_8h.html#ad090d0faa53f44e0377c8d63dab3fa20">mean</a> = <span class="keyword">new</span> DIST_TYPE[veclen_];
<a name="l00663"></a>00663         memoryCounter += (int)(veclen_*<span class="keyword">sizeof</span>(DIST_TYPE));
<a name="l00664"></a>00664 
<a name="l00665"></a>00665         memset(mean,0,veclen_*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00666"></a>00666 
<a name="l00667"></a>00667         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;size_;++i) {
<a name="l00668"></a>00668             ELEM_TYPE* vec = dataset[indices[i]];
<a name="l00669"></a>00669             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;veclen_;++j) {
<a name="l00670"></a>00670                 mean[j] += vec[j];
<a name="l00671"></a>00671             }
<a name="l00672"></a>00672             variance += flann_dist(vec,vec+veclen_,<a class="code" href="namespacecvflann.html#a802bce4843ed8c922b28d72b25bfab91">zero</a>());
<a name="l00673"></a>00673         }
<a name="l00674"></a>00674         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;veclen_;++j) {
<a name="l00675"></a>00675             mean[j] /= size_;
<a name="l00676"></a>00676         }
<a name="l00677"></a>00677         variance /= size_;
<a name="l00678"></a>00678         variance -= flann_dist(mean,mean+veclen_,<a class="code" href="namespacecvflann.html#a802bce4843ed8c922b28d72b25bfab91">zero</a>());
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         <span class="keywordtype">double</span> tmp = 0;
<a name="l00681"></a>00681         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;indices_length;++i) {
<a name="l00682"></a>00682             tmp = flann_dist(mean, mean + veclen_, dataset[indices[i]]);
<a name="l00683"></a>00683             <span class="keywordflow">if</span> (tmp&gt;radius) {
<a name="l00684"></a>00684                 radius = tmp;
<a name="l00685"></a>00685             }
<a name="l00686"></a>00686         }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         node-&gt;variance = (DIST_TYPE)variance;
<a name="l00689"></a>00689         node-&gt;radius = (DIST_TYPE)radius;
<a name="l00690"></a>00690         node-&gt;pivot = <a class="code" href="core__c_8h.html#ad090d0faa53f44e0377c8d63dab3fa20">mean</a>;
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 
<a name="l00705"></a>00705     <span class="keywordtype">void</span> computeClustering(KMeansNode node, <span class="keywordtype">int</span>* indices, <span class="keywordtype">int</span> indices_length, <span class="keywordtype">int</span> branching, <span class="keywordtype">int</span> <a class="code" href="imgproc__c_8h.html#ac693e272fb1883fe0343f55a14d72b22">level</a>)
<a name="l00706"></a>00706     {
<a name="l00707"></a>00707         node-&gt;size = indices_length;
<a name="l00708"></a>00708         node-&gt;level = <a class="code" href="imgproc__c_8h.html#ac693e272fb1883fe0343f55a14d72b22">level</a>;
<a name="l00709"></a>00709 
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (indices_length &lt; branching) {
<a name="l00711"></a>00711             node-&gt;indices = indices;
<a name="l00712"></a>00712             <a class="code" href="namespacecv.html#aad9b72b24146c673236033a113c9ed41" title="sorts independently each matrix row or each matrix column">std::sort</a>(node-&gt;indices,node-&gt;indices+indices_length);
<a name="l00713"></a>00713             node-&gt;childs = NULL;
<a name="l00714"></a>00714             <span class="keywordflow">return</span>;
<a name="l00715"></a>00715         }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         <span class="keywordtype">int</span>* centers_idx = <span class="keyword">new</span> <span class="keywordtype">int</span>[branching];
<a name="l00718"></a>00718         <span class="keywordtype">int</span> centers_length;
<a name="l00719"></a>00719         (this-&gt;*chooseCenters)(branching, indices, indices_length, centers_idx, centers_length);
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         <span class="keywordflow">if</span> (centers_length&lt;branching) {
<a name="l00722"></a>00722             node-&gt;indices = indices;
<a name="l00723"></a>00723             <a class="code" href="namespacecv.html#aad9b72b24146c673236033a113c9ed41" title="sorts independently each matrix row or each matrix column">std::sort</a>(node-&gt;indices,node-&gt;indices+indices_length);
<a name="l00724"></a>00724             node-&gt;childs = NULL;
<a name="l00725"></a>00725             <span class="keywordflow">return</span>;
<a name="l00726"></a>00726         }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 
<a name="l00729"></a>00729         Matrix&lt;double&gt; dcenters(<span class="keyword">new</span> <span class="keywordtype">double</span>[branching*veclen_],branching,(<span class="keywordtype">long</span>)veclen_);
<a name="l00730"></a>00730         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;centers_length; ++i) {
<a name="l00731"></a>00731             ELEM_TYPE* vec = dataset[centers_idx[i]];
<a name="l00732"></a>00732             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0; k&lt;veclen_; ++<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>) {
<a name="l00733"></a>00733                 dcenters[i][<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>] = double(vec[k]);
<a name="l00734"></a>00734             }
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736         <span class="keyword">delete</span>[] centers_idx;
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="keywordtype">float</span>* radiuses = <span class="keyword">new</span> <span class="keywordtype">float</span>[branching];
<a name="l00739"></a>00739         <span class="keywordtype">int</span>* <a class="code" href="calib3d_8hpp.html#a88d78b1935cd8bdee70a44eaaf326b1e">count</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[branching];
<a name="l00740"></a>00740         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;branching;++i) {
<a name="l00741"></a>00741             radiuses[i] = 0;
<a name="l00742"></a>00742             count[i] = 0;
<a name="l00743"></a>00743         }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         <span class="comment">//  assign points to clusters</span>
<a name="l00746"></a>00746         <span class="keywordtype">int</span>* belongs_to = <span class="keyword">new</span> <span class="keywordtype">int</span>[indices_length];
<a name="l00747"></a>00747         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;indices_length;++i) {
<a name="l00748"></a>00748 
<a name="l00749"></a>00749             <span class="keywordtype">double</span> sq_dist = flann_dist(dataset[indices[i]], dataset[indices[i]] + veclen_ ,dcenters[0]);
<a name="l00750"></a>00750             belongs_to[i] = 0;
<a name="l00751"></a>00751             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=1;j&lt;branching;++j) {
<a name="l00752"></a>00752                 <span class="keywordtype">double</span> new_sq_dist = flann_dist(dataset[indices[i]], dataset[indices[i]]+veclen_, dcenters[j]);
<a name="l00753"></a>00753                 <span class="keywordflow">if</span> (sq_dist&gt;new_sq_dist) {
<a name="l00754"></a>00754                     belongs_to[i] = j;
<a name="l00755"></a>00755                     sq_dist = new_sq_dist;
<a name="l00756"></a>00756                 }
<a name="l00757"></a>00757             }
<a name="l00758"></a>00758             <span class="keywordflow">if</span> (sq_dist&gt;radiuses[belongs_to[i]]) {
<a name="l00759"></a>00759                 radiuses[belongs_to[i]] = (float)sq_dist;
<a name="l00760"></a>00760             }
<a name="l00761"></a>00761             count[belongs_to[i]]++;
<a name="l00762"></a>00762         }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764         <span class="keywordtype">bool</span> converged = <span class="keyword">false</span>;
<a name="l00765"></a>00765         <span class="keywordtype">int</span> iteration = 0;
<a name="l00766"></a>00766         <span class="keywordflow">while</span> (!converged &amp;&amp; iteration&lt;max_iter) {
<a name="l00767"></a>00767             converged = <span class="keyword">true</span>;
<a name="l00768"></a>00768             iteration++;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770             <span class="comment">// compute the new cluster centers</span>
<a name="l00771"></a>00771             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;branching;++i) {
<a name="l00772"></a>00772                 memset(dcenters[i],0,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*veclen_);
<a name="l00773"></a>00773                 radiuses[i] = 0;
<a name="l00774"></a>00774             }
<a name="l00775"></a>00775             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;indices_length;++i) {
<a name="l00776"></a>00776                 ELEM_TYPE* vec = dataset[indices[i]];
<a name="l00777"></a>00777                 <span class="keywordtype">double</span>* <a class="code" href="core__c_8h.html#a3f007d4bba0b0e0a4cbcb681f97f241c">center</a> = dcenters[belongs_to[i]];
<a name="l00778"></a>00778                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0;k&lt;veclen_;++<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>) {
<a name="l00779"></a>00779                     center[<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>] += vec[<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>];
<a name="l00780"></a>00780                 }
<a name="l00781"></a>00781             }
<a name="l00782"></a>00782             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;branching;++i) {
<a name="l00783"></a>00783                 <span class="keywordtype">int</span> cnt = count[i];
<a name="l00784"></a>00784                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0;k&lt;veclen_;++<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>) {
<a name="l00785"></a>00785                     dcenters[i][<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>] /= cnt;
<a name="l00786"></a>00786                 }
<a name="l00787"></a>00787             }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789             <span class="comment">// reassign points to clusters</span>
<a name="l00790"></a>00790             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;indices_length;++i) {
<a name="l00791"></a>00791                 <span class="keywordtype">float</span> sq_dist = (float)flann_dist(dataset[indices[i]], dataset[indices[i]]+veclen_ ,dcenters[0]);
<a name="l00792"></a>00792                 <span class="keywordtype">int</span> new_centroid = 0;
<a name="l00793"></a>00793                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=1;j&lt;branching;++j) {
<a name="l00794"></a>00794                     <span class="keywordtype">float</span> new_sq_dist = (float)flann_dist(dataset[indices[i]], dataset[indices[i]]+veclen_,dcenters[j]);
<a name="l00795"></a>00795                     <span class="keywordflow">if</span> (sq_dist&gt;new_sq_dist) {
<a name="l00796"></a>00796                         new_centroid = j;
<a name="l00797"></a>00797                         sq_dist = new_sq_dist;
<a name="l00798"></a>00798                     }
<a name="l00799"></a>00799                 }
<a name="l00800"></a>00800                 <span class="keywordflow">if</span> (sq_dist&gt;radiuses[new_centroid]) {
<a name="l00801"></a>00801                     radiuses[new_centroid] = sq_dist;
<a name="l00802"></a>00802                 }
<a name="l00803"></a>00803                 <span class="keywordflow">if</span> (new_centroid != belongs_to[i]) {
<a name="l00804"></a>00804                     count[belongs_to[i]]--;
<a name="l00805"></a>00805                     count[new_centroid]++;
<a name="l00806"></a>00806                     belongs_to[i] = new_centroid;
<a name="l00807"></a>00807 
<a name="l00808"></a>00808                     converged = <span class="keyword">false</span>;
<a name="l00809"></a>00809                 }
<a name="l00810"></a>00810             }
<a name="l00811"></a>00811 
<a name="l00812"></a>00812             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;branching;++i) {
<a name="l00813"></a>00813                 <span class="comment">// if one cluster converges to an empty cluster,</span>
<a name="l00814"></a>00814                 <span class="comment">// move an element into that cluster</span>
<a name="l00815"></a>00815                 <span class="keywordflow">if</span> (count[i]==0) {
<a name="l00816"></a>00816                     <span class="keywordtype">int</span> j = (i+1)%branching;
<a name="l00817"></a>00817                     <span class="keywordflow">while</span> (count[j]&lt;=1) {
<a name="l00818"></a>00818                         j = (j+1)%branching;
<a name="l00819"></a>00819                     }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;indices_length;++<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>) {
<a name="l00822"></a>00822                         <span class="keywordflow">if</span> (belongs_to[k]==j) {
<a name="l00823"></a>00823                             belongs_to[<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>] = i;
<a name="l00824"></a>00824                             count[j]--;
<a name="l00825"></a>00825                             count[i]++;
<a name="l00826"></a>00826                             <span class="keywordflow">break</span>;
<a name="l00827"></a>00827                         }
<a name="l00828"></a>00828                     }
<a name="l00829"></a>00829                     converged = <span class="keyword">false</span>;
<a name="l00830"></a>00830                 }
<a name="l00831"></a>00831             }
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835         DIST_TYPE** centers = <span class="keyword">new</span> DIST_TYPE*[branching];
<a name="l00836"></a>00836 
<a name="l00837"></a>00837         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;branching; ++i) {
<a name="l00838"></a>00838             centers[i] = <span class="keyword">new</span> DIST_TYPE[veclen_];
<a name="l00839"></a>00839             memoryCounter += (int)(veclen_*<span class="keyword">sizeof</span>(DIST_TYPE));
<a name="l00840"></a>00840             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0; k&lt;veclen_; ++<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>) {
<a name="l00841"></a>00841                 centers[i][<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>] = (DIST_TYPE)dcenters[i][k];
<a name="l00842"></a>00842             }
<a name="l00843"></a>00843         }
<a name="l00844"></a>00844 
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         <span class="comment">// compute kmeans clustering for each of the resulting clusters</span>
<a name="l00847"></a>00847         node-&gt;childs = pool.<a class="code" href="classcvflann_1_1_pooled_allocator.html#aaf127cab57cd0e0f4d3b335efd8d3a67">allocate</a>&lt;KMeansNode&gt;(branching);
<a name="l00848"></a>00848         <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a45314566a84a31f43e6435d1eb24d4ec">start</a> = 0;
<a name="l00849"></a>00849         <span class="keywordtype">int</span> <a class="code" href="core__c_8h.html#a338bddb6320c8e898e204d6273af2d67">end</a> = <a class="code" href="core__c_8h.html#a45314566a84a31f43e6435d1eb24d4ec">start</a>;
<a name="l00850"></a>00850         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>=0;<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>&lt;branching;++<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>) {
<a name="l00851"></a>00851             <span class="keywordtype">int</span> s = count[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>];
<a name="l00852"></a>00852 
<a name="l00853"></a>00853             <span class="keywordtype">double</span> variance = 0;
<a name="l00854"></a>00854             <span class="keywordtype">double</span> mean_radius =0;
<a name="l00855"></a>00855             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;indices_length;++i) {
<a name="l00856"></a>00856                 <span class="keywordflow">if</span> (belongs_to[i]==<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>) {
<a name="l00857"></a>00857                     <span class="keywordtype">double</span> <a class="code" href="imgproc__c_8h.html#a6f364afbe132c4ecfea48bde1b0618ba">d</a> = flann_dist(dataset[indices[i]],dataset[indices[i]]+veclen_,<a class="code" href="namespacecvflann.html#a802bce4843ed8c922b28d72b25bfab91">zero</a>());
<a name="l00858"></a>00858                     variance += <a class="code" href="imgproc__c_8h.html#a6f364afbe132c4ecfea48bde1b0618ba">d</a>;
<a name="l00859"></a>00859                     mean_radius += <a class="code" href="namespacecv.html#a2ae54521731aa4bcf7bc5042a2db88bb" title="computes square root of each matrix element (dst = src**0.5)">sqrt</a>(d);
<a name="l00860"></a>00860                     <a class="code" href="namespacecv.html#aee66fd35ceb08e5e93177b123481a25e" title="swaps two matrices">std::swap</a>(indices[i],indices[end]);
<a name="l00861"></a>00861                     <a class="code" href="namespacecv.html#aee66fd35ceb08e5e93177b123481a25e" title="swaps two matrices">std::swap</a>(belongs_to[i],belongs_to[end]);
<a name="l00862"></a>00862                     end++;
<a name="l00863"></a>00863                 }
<a name="l00864"></a>00864             }
<a name="l00865"></a>00865             variance /= s;
<a name="l00866"></a>00866             mean_radius /= s;
<a name="l00867"></a>00867             variance -= flann_dist(centers[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>],centers[c]+veclen_,<a class="code" href="namespacecvflann.html#a802bce4843ed8c922b28d72b25bfab91">zero</a>());
<a name="l00868"></a>00868 
<a name="l00869"></a>00869             node-&gt;childs[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>] = pool.<a class="code" href="classcvflann_1_1_pooled_allocator.html#aaf127cab57cd0e0f4d3b335efd8d3a67">allocate</a>&lt;KMeansNodeSt&gt;();
<a name="l00870"></a>00870             node-&gt;childs[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>]-&gt;radius = radiuses[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>];
<a name="l00871"></a>00871             node-&gt;childs[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>]-&gt;pivot = centers[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>];
<a name="l00872"></a>00872             node-&gt;childs[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>]-&gt;variance = (float)variance;
<a name="l00873"></a>00873             node-&gt;childs[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>]-&gt;mean_radius = (float)mean_radius;
<a name="l00874"></a>00874             node-&gt;childs[<a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>]-&gt;indices = NULL;
<a name="l00875"></a>00875             computeClustering(node-&gt;childs[c],indices+start, end-start, branching, level+1);
<a name="l00876"></a>00876             start=<a class="code" href="core__c_8h.html#a338bddb6320c8e898e204d6273af2d67">end</a>;
<a name="l00877"></a>00877         }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879         <span class="keyword">delete</span>[] dcenters.data;
<a name="l00880"></a>00880         <span class="keyword">delete</span>[] centers;
<a name="l00881"></a>00881         <span class="keyword">delete</span>[] radiuses;
<a name="l00882"></a>00882         <span class="keyword">delete</span>[] <a class="code" href="calib3d_8hpp.html#a88d78b1935cd8bdee70a44eaaf326b1e">count</a>;
<a name="l00883"></a>00883         <span class="keyword">delete</span>[] belongs_to;
<a name="l00884"></a>00884     }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 
<a name="l00887"></a>00887 
<a name="l00901"></a>00901     <span class="keywordtype">void</span> findNN(KMeansNode node, ResultSet&lt;ELEM_TYPE&gt;&amp; <a class="code" href="core__c_8h.html#a14871c176a686a03035b5f2bbc72a63f">result</a>, <span class="keyword">const</span> ELEM_TYPE* vec, <span class="keywordtype">int</span>&amp; checks, <span class="keywordtype">int</span> maxChecks,
<a name="l00902"></a>00902             Heap&lt;BranchSt&gt;* heap)
<a name="l00903"></a>00903     {
<a name="l00904"></a>00904         <span class="comment">// Ignore those clusters that are too far away</span>
<a name="l00905"></a>00905         {
<a name="l00906"></a>00906             DIST_TYPE bsq = (DIST_TYPE)flann_dist(vec, vec+veclen_, node-&gt;pivot);
<a name="l00907"></a>00907             DIST_TYPE rsq = node-&gt;radius;
<a name="l00908"></a>00908             DIST_TYPE wsq = result.worstDist();
<a name="l00909"></a>00909 
<a name="l00910"></a>00910             DIST_TYPE val = bsq-rsq-wsq;
<a name="l00911"></a>00911             DIST_TYPE val2 = val*val-4*rsq*wsq;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913             <span class="comment">//if (val&gt;0) {</span>
<a name="l00914"></a>00914             <span class="keywordflow">if</span> (val&gt;0 &amp;&amp; val2&gt;0) {
<a name="l00915"></a>00915                 <span class="keywordflow">return</span>;
<a name="l00916"></a>00916             }
<a name="l00917"></a>00917         }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         <span class="keywordflow">if</span> (node-&gt;childs==NULL) {
<a name="l00920"></a>00920             <span class="keywordflow">if</span> (checks&gt;=maxChecks) {
<a name="l00921"></a>00921                 <span class="keywordflow">if</span> (result.full()) <span class="keywordflow">return</span>;
<a name="l00922"></a>00922             }
<a name="l00923"></a>00923             checks += node-&gt;size;
<a name="l00924"></a>00924             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;node-&gt;size;++i) {
<a name="l00925"></a>00925                 result.addPoint(dataset[node-&gt;indices[i]], node-&gt;indices[i]);
<a name="l00926"></a>00926             }
<a name="l00927"></a>00927         }
<a name="l00928"></a>00928         <span class="keywordflow">else</span> {
<a name="l00929"></a>00929             <span class="keywordtype">float</span>* domain_distances = <span class="keyword">new</span> <span class="keywordtype">float</span>[branching];
<a name="l00930"></a>00930             <span class="keywordtype">int</span> closest_center = exploreNodeBranches(node, vec, domain_distances, heap);
<a name="l00931"></a>00931             <span class="keyword">delete</span>[] domain_distances;
<a name="l00932"></a>00932             findNN(node-&gt;childs[closest_center],result,vec, checks, maxChecks, heap);
<a name="l00933"></a>00933         }
<a name="l00934"></a>00934     }
<a name="l00935"></a>00935 
<a name="l00944"></a>00944     <span class="keywordtype">int</span> exploreNodeBranches(KMeansNode node, <span class="keyword">const</span> ELEM_TYPE* q, <span class="keywordtype">float</span>* domain_distances, Heap&lt;BranchSt&gt;* heap)
<a name="l00945"></a>00945     {
<a name="l00946"></a>00946 
<a name="l00947"></a>00947         <span class="keywordtype">int</span> best_index = 0;
<a name="l00948"></a>00948         domain_distances[best_index] = (float)flann_dist(q,q+veclen_,node-&gt;childs[best_index]-&gt;pivot);
<a name="l00949"></a>00949         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1;i&lt;branching;++i) {
<a name="l00950"></a>00950             domain_distances[i] = (float)flann_dist(q,q+veclen_,node-&gt;childs[i]-&gt;pivot);
<a name="l00951"></a>00951             <span class="keywordflow">if</span> (domain_distances[i]&lt;domain_distances[best_index]) {
<a name="l00952"></a>00952                 best_index = i;
<a name="l00953"></a>00953             }
<a name="l00954"></a>00954         }
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 <span class="comment">//      float* best_center = node-&gt;childs[best_index]-&gt;pivot;</span>
<a name="l00957"></a>00957         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;branching;++i) {
<a name="l00958"></a>00958             <span class="keywordflow">if</span> (i != best_index) {
<a name="l00959"></a>00959                 domain_distances[i] -= cb_index*node-&gt;childs[i]-&gt;variance;
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="comment">//              float dist_to_border = getDistanceToBorder(node.childs[i].pivot,best_center,q);</span>
<a name="l00962"></a>00962 <span class="comment">//              if (domain_distances[i]&lt;dist_to_border) {</span>
<a name="l00963"></a>00963 <span class="comment">//                  domain_distances[i] = dist_to_border;</span>
<a name="l00964"></a>00964 <span class="comment">//              }</span>
<a name="l00965"></a>00965                 heap-&gt;insert(<a class="code" href="structcvflann_1_1_branch_struct.html#a0bc27691d94461150c3f4a47f91a7e7a">BranchSt::make_branch</a>(node-&gt;childs[i],domain_distances[i]));
<a name="l00966"></a>00966             }
<a name="l00967"></a>00967         }
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         <span class="keywordflow">return</span> best_index;
<a name="l00970"></a>00970     }
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 
<a name="l00976"></a>00976     <span class="keywordtype">void</span> findExactNN(KMeansNode node, ResultSet&lt;ELEM_TYPE&gt;&amp; result, <span class="keyword">const</span> ELEM_TYPE* vec)
<a name="l00977"></a>00977     {
<a name="l00978"></a>00978         <span class="comment">// Ignore those clusters that are too far away</span>
<a name="l00979"></a>00979         {
<a name="l00980"></a>00980             <span class="keywordtype">float</span> bsq = (float)flann_dist(vec, vec+veclen_, node-&gt;pivot);
<a name="l00981"></a>00981             <span class="keywordtype">float</span> rsq = node-&gt;radius;
<a name="l00982"></a>00982             <span class="keywordtype">float</span> wsq = result.worstDist();
<a name="l00983"></a>00983 
<a name="l00984"></a>00984             <span class="keywordtype">float</span> val = bsq-rsq-wsq;
<a name="l00985"></a>00985             <span class="keywordtype">float</span> val2 = val*val-4*rsq*wsq;
<a name="l00986"></a>00986 
<a name="l00987"></a>00987     <span class="comment">//          if (val&gt;0) {</span>
<a name="l00988"></a>00988             <span class="keywordflow">if</span> (val&gt;0 &amp;&amp; val2&gt;0) {
<a name="l00989"></a>00989                 <span class="keywordflow">return</span>;
<a name="l00990"></a>00990             }
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 
<a name="l00994"></a>00994         <span class="keywordflow">if</span> (node-&gt;childs==NULL) {
<a name="l00995"></a>00995             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;node-&gt;size;++i) {
<a name="l00996"></a>00996                 result.addPoint(dataset[node-&gt;indices[i]], node-&gt;indices[i]);
<a name="l00997"></a>00997             }
<a name="l00998"></a>00998         }
<a name="l00999"></a>00999         <span class="keywordflow">else</span> {
<a name="l01000"></a>01000             <span class="keywordtype">int</span>* sort_indices = <span class="keyword">new</span> <span class="keywordtype">int</span>[branching];
<a name="l01001"></a>01001 
<a name="l01002"></a>01002             getCenterOrdering(node, vec, sort_indices);
<a name="l01003"></a>01003 
<a name="l01004"></a>01004             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;branching; ++i) {
<a name="l01005"></a>01005                 findExactNN(node-&gt;childs[sort_indices[i]],result,vec);
<a name="l01006"></a>01006             }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008             <span class="keyword">delete</span>[] sort_indices;
<a name="l01009"></a>01009         }
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 
<a name="l01018"></a>01018     <span class="keywordtype">void</span> getCenterOrdering(KMeansNode node, <span class="keyword">const</span> ELEM_TYPE* q, <span class="keywordtype">int</span>* sort_indices)
<a name="l01019"></a>01019     {
<a name="l01020"></a>01020         <span class="keywordtype">float</span>* domain_distances = <span class="keyword">new</span> <span class="keywordtype">float</span>[branching];
<a name="l01021"></a>01021         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;branching;++i) {
<a name="l01022"></a>01022             <span class="keywordtype">float</span> <a class="code" href="imgproc__c_8h.html#a5ff9213baa788fe8470a05e0b2b8cdb8">dist</a> = (float)flann_dist(q, q+veclen_, node-&gt;childs[i]-&gt;pivot);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024             <span class="keywordtype">int</span> j=0;
<a name="l01025"></a>01025             <span class="keywordflow">while</span> (domain_distances[j]&lt;dist &amp;&amp; j&lt;i) j++;
<a name="l01026"></a>01026             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=i;k&gt;j;--<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>) {
<a name="l01027"></a>01027                 domain_distances[<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>] = domain_distances[k-1];
<a name="l01028"></a>01028                 sort_indices[<a class="code" href="imgproc__c_8h.html#a7be9b6436e5ea72ff5d5a66779b4bd38">k</a>] = sort_indices[k-1];
<a name="l01029"></a>01029             }
<a name="l01030"></a>01030             domain_distances[j] = <a class="code" href="imgproc__c_8h.html#a5ff9213baa788fe8470a05e0b2b8cdb8">dist</a>;
<a name="l01031"></a>01031             sort_indices[j] = i;
<a name="l01032"></a>01032         }
<a name="l01033"></a>01033         <span class="keyword">delete</span>[] domain_distances;
<a name="l01034"></a>01034     }
<a name="l01035"></a>01035 
<a name="l01041"></a>01041     <span class="keywordtype">float</span> getDistanceToBorder(<span class="keywordtype">float</span>* p, <span class="keywordtype">float</span>* <a class="code" href="legacy_8hpp.html#a1971420173e06f45845eed2ab4e3d5d0">c</a>, <span class="keywordtype">float</span>* q)
<a name="l01042"></a>01042     {
<a name="l01043"></a>01043         <span class="keywordtype">float</span> <a class="code" href="namespacecv.html#aa012757b1a6536a1a3ef813a0aba1c1e">sum</a> = 0;
<a name="l01044"></a>01044         <span class="keywordtype">float</span> sum2 = 0;
<a name="l01045"></a>01045 
<a name="l01046"></a>01046         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;veclen_; ++i) {
<a name="l01047"></a>01047             <span class="keywordtype">float</span> t = c[i]-p[i];
<a name="l01048"></a>01048             sum += t*(q[i]-(c[i]+p[i])/2);
<a name="l01049"></a>01049             sum2 += t*t;
<a name="l01050"></a>01050         }
<a name="l01051"></a>01051 
<a name="l01052"></a>01052         <span class="keywordflow">return</span> sum*sum/sum2;
<a name="l01053"></a>01053     }
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 
<a name="l01065"></a>01065     <span class="keywordtype">int</span> getMinVarianceClusters(KMeansNode root, KMeansNode* clusters, <span class="keywordtype">int</span> clusters_length, <span class="keywordtype">float</span>&amp; varianceValue)
<a name="l01066"></a>01066     {
<a name="l01067"></a>01067         <span class="keywordtype">int</span> clusterCount = 1;
<a name="l01068"></a>01068         clusters[0] = root;
<a name="l01069"></a>01069 
<a name="l01070"></a>01070         <span class="keywordtype">float</span> meanVariance = root-&gt;variance*root-&gt;size;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072         <span class="keywordflow">while</span> (clusterCount&lt;clusters_length) {
<a name="l01073"></a>01073             <span class="keywordtype">float</span> minVariance = (<a class="code" href="namespacecv.html#a22a8f8afb6090a66a771348b658dcebd" title="computes per-element maximum of two arrays (dst = max(src1, src2))">std::numeric_limits&lt;float&gt;::max</a>)();
<a name="l01074"></a>01074             <span class="keywordtype">int</span> splitIndex = -1;
<a name="l01075"></a>01075 
<a name="l01076"></a>01076             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;clusterCount;++i) {
<a name="l01077"></a>01077                 <span class="keywordflow">if</span> (clusters[i]-&gt;childs != NULL) {
<a name="l01078"></a>01078 
<a name="l01079"></a>01079                     <span class="keywordtype">float</span> variance = meanVariance - clusters[i]-&gt;variance*clusters[i]-&gt;size;
<a name="l01080"></a>01080 
<a name="l01081"></a>01081                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;branching;++j) {
<a name="l01082"></a>01082                         variance += clusters[i]-&gt;childs[j]-&gt;variance*clusters[i]-&gt;childs[j]-&gt;size;
<a name="l01083"></a>01083                     }
<a name="l01084"></a>01084                     <span class="keywordflow">if</span> (variance&lt;minVariance) {
<a name="l01085"></a>01085                         minVariance = variance;
<a name="l01086"></a>01086                         splitIndex = i;
<a name="l01087"></a>01087                     }
<a name="l01088"></a>01088                 }
<a name="l01089"></a>01089             }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091             <span class="keywordflow">if</span> (splitIndex==-1) <span class="keywordflow">break</span>;
<a name="l01092"></a>01092             <span class="keywordflow">if</span> ( (branching+clusterCount-1) &gt; clusters_length) <span class="keywordflow">break</span>;
<a name="l01093"></a>01093 
<a name="l01094"></a>01094             meanVariance = minVariance;
<a name="l01095"></a>01095 
<a name="l01096"></a>01096             <span class="comment">// split node</span>
<a name="l01097"></a>01097             KMeansNode toSplit = clusters[splitIndex];
<a name="l01098"></a>01098             clusters[splitIndex] = toSplit-&gt;childs[0];
<a name="l01099"></a>01099             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1;i&lt;branching;++i) {
<a name="l01100"></a>01100                 clusters[clusterCount++] = toSplit-&gt;childs[i];
<a name="l01101"></a>01101             }
<a name="l01102"></a>01102         }
<a name="l01103"></a>01103 
<a name="l01104"></a>01104         varianceValue = meanVariance/root-&gt;size;
<a name="l01105"></a>01105         <span class="keywordflow">return</span> clusterCount;
<a name="l01106"></a>01106     }
<a name="l01107"></a>01107 };
<a name="l01108"></a>01108 
<a name="l01109"></a>01109 
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 <span class="comment">//register_index(KMEANS,KMeansTree)</span>
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 } <span class="comment">// namespace cvflann</span>
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="preprocessor">#endif //_OPENCV_KMEANSTREE_H_</span>
</pre></div></div><!-- contents -->
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>
