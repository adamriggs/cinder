<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Cinder</title>
		<link rel="stylesheet" href="cinder_doxygen.css" type="text/css" media="screen" />
		<script type="text/javascript" src="jquery-1.4.2.min.js"></script>
		<script type="text/javascript" src="jquery.lightbox-0.5.pack.js"></script>		
	</head>
<body>	
<div class="wrapper">
	<div id="header">
		<h1><a href="http://libcinder.org">Cinder</a></h1>
	</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">include/cinder/Xml.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_xml_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> Copyright (c) 2010, The Cinder Project</span>
<a name="l00003"></a>00003 <span class="comment"> All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment"> </span>
<a name="l00005"></a>00005 <span class="comment"> This code is designed for use with the Cinder C++ library, http://libcinder.org</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment"> Redistribution and use in source and binary forms, with or without modification, are permitted provided that</span>
<a name="l00008"></a>00008 <span class="comment"> the following conditions are met:</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    * Redistributions of source code must retain the above copyright notice, this list of conditions and</span>
<a name="l00011"></a>00011 <span class="comment">    the following disclaimer.</span>
<a name="l00012"></a>00012 <span class="comment">    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and</span>
<a name="l00013"></a>00013 <span class="comment">    the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment"> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED</span>
<a name="l00016"></a>00016 <span class="comment"> WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A</span>
<a name="l00017"></a>00017 <span class="comment"> PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR</span>
<a name="l00018"></a>00018 <span class="comment"> ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED</span>
<a name="l00019"></a>00019 <span class="comment"> TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<a name="l00020"></a>00020 <span class="comment"> HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00021"></a>00021 <span class="comment"> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a name="l00022"></a>00022 <span class="comment"> POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00023"></a>00023 <span class="comment">*/</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#pragma once</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="_cinder_8h.html">cinder/Cinder.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="_stream_8h.html">cinder/Stream.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="_data_source_8h.html">cinder/DataSource.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="_data_target_8h.html">cinder/DataTarget.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="_exception_8h.html">cinder/Exception.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="_utilities_8h.html">cinder/Utilities.h</a>&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00038"></a>00038 
<a name="l00040"></a>00040 <span class="keyword">namespace </span>rapidxml {
<a name="l00041"></a>00041     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch&gt; <span class="keyword">class </span>xml_document;
<a name="l00042"></a>00042     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch&gt; <span class="keyword">class </span>xml_node;
<a name="l00043"></a>00043 };
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">namespace </span>cinder {
<a name="l00047"></a>00047 
<a name="l00048"></a><a class="code" href="classcinder_1_1_xml_tree.html">00048</a> <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> {
<a name="l00049"></a>00049   <span class="keyword">public</span>:
<a name="l00051"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html">00051</a>     <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a> {
<a name="l00052"></a>00052       <span class="keyword">public</span>:
<a name="l00054"></a>00054         <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( <span class="keyword">const</span> std::list&lt;XmlTree&gt; *sequence );        
<a name="l00055"></a>00055         <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( <span class="keyword">const</span> std::list&lt;XmlTree&gt; *sequence, std::list&lt;XmlTree&gt;::const_iterator iter );       
<a name="l00056"></a>00056         <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;root, <span class="keyword">const</span> std::string &amp;filterPath, <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> );
<a name="l00058"></a>00058 
<a name="l00060"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#a43c748768c7a3d1c5010dd89a1ccddca">00060</a>         <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;      <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#a43c748768c7a3d1c5010dd89a1ccddca">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *mIterStack.back(); }
<a name="l00062"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#af30218a2a3c442ca17ac902e1fcef4c9">00062</a>         <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>*      <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#af30218a2a3c442ca17ac902e1fcef4c9" title="Returns a pointer to the XmlTree the iterator currently points to.">operator-&gt;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;(*mIterStack.back()); }
<a name="l00063"></a>00063 
<a name="l00065"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#ae80043481eab6eda6a4d75441bbed9d3">00065</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>&amp; <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#ae80043481eab6eda6a4d75441bbed9d3" title="Increments the iterator to the next child. If using a non-empty filterPath increments to the next chi...">operator++</a>() {
<a name="l00066"></a>00066             increment();
<a name="l00067"></a>00067             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00068"></a>00068         }
<a name="l00069"></a>00069         
<a name="l00071"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#a004b361133024a22c9007e8f8a5e9420">00071</a>         <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#a004b361133024a22c9007e8f8a5e9420" title="Increments the iterator to the next child. If using a non-empty filterPath increments to the next chi...">operator++</a>(<span class="keywordtype">int</span>) {
<a name="l00072"></a>00072             <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a> prev( *<span class="keyword">this</span> );
<a name="l00073"></a>00073             ++(*this);
<a name="l00074"></a>00074             <span class="keywordflow">return</span> prev; 
<a name="l00075"></a>00075         }
<a name="l00076"></a>00076         
<a name="l00077"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#a4d4263972e3c2520c30f296d2e28264d">00077</a>         <span class="keywordtype">bool</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#a4d4263972e3c2520c30f296d2e28264d">operator!=</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a> &amp;rhs ) { <span class="keywordflow">return</span> ( mSequenceStack.back() != rhs.mSequenceStack.back() ) || ( mIterStack.back() != rhs.mIterStack.back() ); }
<a name="l00078"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#aa4871a46de38cab83d022c488c9bff25">00078</a>         <span class="keywordtype">bool</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html#aa4871a46de38cab83d022c488c9bff25">operator==</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a> &amp;rhs ) { <span class="keywordflow">return</span> ( mSequenceStack.back() == rhs.mSequenceStack.back() ) &amp;&amp; ( mIterStack.back() == rhs.mIterStack.back() ); }
<a name="l00079"></a>00079         
<a name="l00080"></a>00080       <span class="keyword">protected</span>:
<a name="l00082"></a>00082         <span class="keywordtype">void</span>    increment();
<a name="l00083"></a>00083         <span class="keywordtype">void</span>    setToEnd( <span class="keyword">const</span> std::list&lt;XmlTree&gt; *seq );
<a name="l00084"></a>00084         <span class="keywordtype">bool</span>    isDone() <span class="keyword">const</span>;
<a name="l00085"></a>00085         
<a name="l00086"></a>00086         std::vector&lt;const std::list&lt;XmlTree&gt;*&gt;              mSequenceStack;
<a name="l00087"></a>00087         std::vector&lt;std::list&lt;XmlTree&gt;::const_iterator&gt;     mIterStack;
<a name="l00088"></a>00088         std::vector&lt;std::string&gt;                            mFilter;
<a name="l00089"></a>00089         <span class="keywordtype">bool</span>                                                mCaseSensitive;
<a name="l00091"></a>00091     };
<a name="l00092"></a>00092 
<a name="l00094"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html">00094</a>     <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a> : <span class="keyword">public</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">XmlTree::ConstIter</a> {
<a name="l00095"></a>00095       <span class="keyword">public</span>:
<a name="l00097"></a>00097         <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>( std::list&lt;XmlTree&gt; *sequence )
<a name="l00098"></a>00098             : <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( sequence )
<a name="l00099"></a>00099         {}
<a name="l00100"></a>00100         
<a name="l00101"></a>00101         <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>( std::list&lt;XmlTree&gt; *sequence, std::list&lt;XmlTree&gt;::iterator iter )
<a name="l00102"></a>00102             : <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( sequence, iter )
<a name="l00103"></a>00103         {}
<a name="l00104"></a>00104     
<a name="l00105"></a>00105         <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>( <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;root, <span class="keyword">const</span> std::string &amp;filterPath, <span class="keywordtype">bool</span> caseSensitive, <span class="keywordtype">char</span> separator )
<a name="l00106"></a>00106             : <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( root, filterPath, caseSensitive, separator )
<a name="l00107"></a>00107         {}
<a name="l00109"></a>00109 
<a name="l00110"></a>00110         
<a name="l00112"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#a1bf3a0ec3a087b1e3d37cabb9abfd49a">00112</a>         <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;        <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#a1bf3a0ec3a087b1e3d37cabb9abfd49a">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;<span class="keyword">&gt;</span>(*mIterStack.back()); }
<a name="l00114"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#afc8f5b83a85fd0092b13d495a468a44e">00114</a>         <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>*        <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#afc8f5b83a85fd0092b13d495a468a44e" title="Returns a pointer to the XmlTree the iterator currently points to.">operator-&gt;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>*<span class="keyword">&gt;</span>( &amp;(*mIterStack.back()) ); }
<a name="l00115"></a>00115 
<a name="l00117"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#abf0a472c3d219a60fcfc1d2788eb25f2">00117</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>&amp; <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#abf0a472c3d219a60fcfc1d2788eb25f2" title="Increments the iterator to the next child. If using a non-empty filterPath increments to the next chi...">operator++</a>() {
<a name="l00118"></a>00118             increment();
<a name="l00119"></a>00119             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121         
<a name="l00123"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#a2993c9e67e1eae3777e08449e9556a7f">00123</a>         <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#a2993c9e67e1eae3777e08449e9556a7f" title="Increments the iterator to the next child. If using a non-empty filterPath increments to the next chi...">operator++</a>(<span class="keywordtype">int</span>) {
<a name="l00124"></a>00124             <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a> prev( *<span class="keyword">this</span> );
<a name="l00125"></a>00125             ++(*this);
<a name="l00126"></a>00126             <span class="keywordflow">return</span> prev; 
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128         
<a name="l00129"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#a0f927173eb90432029a083c5cb2387b8">00129</a>         <span class="keywordtype">bool</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#a0f927173eb90432029a083c5cb2387b8">operator!=</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a> &amp;rhs ) { <span class="keywordflow">return</span> ( mSequenceStack.back() != rhs.mSequenceStack.back() ) || ( mIterStack.back() != rhs.mIterStack.back() ); }
<a name="l00130"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#abe556a2444b8b0db1e5a2f61e5b15f6a">00130</a>         <span class="keywordtype">bool</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html#abe556a2444b8b0db1e5a2f61e5b15f6a">operator==</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a> &amp;rhs ) { <span class="keywordflow">return</span> ( mSequenceStack.back() == rhs.mSequenceStack.back() ) &amp;&amp; ( mIterStack.back() == rhs.mIterStack.back() ); }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     };
<a name="l00133"></a>00133 
<a name="l00135"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html">00135</a>     <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html" title="XML attribute.">Attr</a> {
<a name="l00136"></a>00136       <span class="keyword">public</span>:
<a name="l00138"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a4da06418e7cb33e89539a6d3d60edc7b">00138</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a4da06418e7cb33e89539a6d3d60edc7b" title="Constructs an XML attribute named name with the value value.">Attr</a>( <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> *xml, <span class="keyword">const</span> std::string &amp;name, <span class="keyword">const</span> std::string &amp;value )
<a name="l00139"></a>00139             : mXml( xml ), mName( name ), mValue( value )
<a name="l00140"></a>00140         {}
<a name="l00141"></a>00141 
<a name="l00143"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a210904d7cdd18f98d6d6cd689423dfd1">00143</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a210904d7cdd18f98d6d6cd689423dfd1" title="Returns an empty string for a non-existent attribute.">operator const std::string&amp;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mValue; }
<a name="l00145"></a>00145         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00146"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a9bc9686e6898a95d9c477bb43c4ba3f4">00146</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html" title="XML attribute.">Attr</a>&amp;   <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a9bc9686e6898a95d9c477bb43c4ba3f4" title="Assigns the Attr a new value, and creates it if it doesn&#39;t exist. The equivalent of calling setAttrib...">operator=</a>( <span class="keyword">const</span> T&amp; val ) { mValue = <a class="code" href="namespacecinder.html#ac77d757b302731879c7ad8525eaa90de">toString</a>( val ); mXml-&gt;<a class="code" href="classcinder_1_1_xml_tree.html#a83360683794db21d32e54ff36c18ca8b">setAttribute</a>( mName, mValue ); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00147"></a>00147         
<a name="l00149"></a>00149         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00150"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#aa735ca34a55ebbcd13bb853eb6b20b41">00150</a>         T       <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#aa735ca34a55ebbcd13bb853eb6b20b41" title="Returns the value of the attribute cast to T using ci::fromString().">as</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fromString&lt;T&gt;( mValue ); }
<a name="l00151"></a>00151         
<a name="l00153"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a70ff225c5eeef35da26c12e4a0fa262d">00153</a>         <span class="keywordtype">bool</span>    <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a70ff225c5eeef35da26c12e4a0fa262d" title="Returns true if the Attr value is empty.">empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mValue.empty(); }
<a name="l00154"></a>00154         
<a name="l00156"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a7c3f3133d0f6b0898dd517018e3f72c7">00156</a>         <span class="keyword">const</span> std::string&amp;      <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a7c3f3133d0f6b0898dd517018e3f72c7" title="Returns the name of the attribute as a string.">getName</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mName; }
<a name="l00158"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#ae59186d3bc4c232ee93a477aec64946b">00158</a>         std::string             <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#ae59186d3bc4c232ee93a477aec64946b" title="Returns the value of the attribute as a string.">getValue</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mValue; }
<a name="l00161"></a>00161         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00162"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#ab2755d29491b544bbab3be41cec79bc8">00162</a>         T                       <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#ab2755d29491b544bbab3be41cec79bc8" title="Returns the value of the attribute parsed as a T. Requires T to support the istream&gt;&gt; operator...">getValue</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fromString&lt;T&gt;( mValue ); }
<a name="l00163"></a>00163         
<a name="l00165"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#aaefff4f9bd349279f65719bb17ab4e21">00165</a>         <span class="keywordtype">void</span>                    <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#aaefff4f9bd349279f65719bb17ab4e21">setValue</a>( <span class="keyword">const</span> std::string &amp;value ) { mValue = value; }
<a name="l00167"></a>00167         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00168"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a0c0c3187b7ee0c61c6e3ba66c537e82f">00168</a>         <span class="keywordtype">void</span>                    <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#a0c0c3187b7ee0c61c6e3ba66c537e82f">setValue</a>( <span class="keyword">const</span> T &amp;value ) { mValue = boost::lexical_cast&lt;std::string&gt;( value ); }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170       <span class="keyword">private</span>:
<a name="l00171"></a>00171         <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>         *mXml;
<a name="l00172"></a>00172         std::string     mName, mValue;
<a name="l00173"></a>00173     };
<a name="l00174"></a>00174 
<a name="l00176"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html">00176</a>     <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html" title="Options for XML parsing. Passed to the XmlTree constructor.">ParseOptions</a> {
<a name="l00177"></a>00177       <span class="keyword">public</span>:
<a name="l00179"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a46bacca3dc71d36cb84bd378238baf67">00179</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a46bacca3dc71d36cb84bd378238baf67" title="Default options. Disables parsing comments, enables collapsing CDATA, ignores data children...">ParseOptions</a>() : mParseComments( false ), mCollapseCData( true ), mIgnoreDataChildren( true ) {}
<a name="l00180"></a>00180         
<a name="l00182"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a86015d0dcf27100e9a0b86d74071b9a2">00182</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html" title="Options for XML parsing. Passed to the XmlTree constructor.">ParseOptions</a>&amp; <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a86015d0dcf27100e9a0b86d74071b9a2" title="Sets whether XML comments are parsed or not.">parseComments</a>( <span class="keywordtype">bool</span> parse = <span class="keyword">true</span> ) { mParseComments = parse; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00184"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a43b0360a96779db5a6bc1442f4913696">00184</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html" title="Options for XML parsing. Passed to the XmlTree constructor.">ParseOptions</a>&amp; <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a43b0360a96779db5a6bc1442f4913696" title="Sets whether CDATA blocks are collapsed automatically or not.">collapseCData</a>( <span class="keywordtype">bool</span> collapse = <span class="keyword">true</span> ) { mCollapseCData = collapse; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00186"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#ad54a1262fc2556b1faf84f73934b4ad9">00186</a>         <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html" title="Options for XML parsing. Passed to the XmlTree constructor.">ParseOptions</a>&amp; <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#ad54a1262fc2556b1faf84f73934b4ad9" title="Sets whether data nodes are created as children, in addition to being available as the value of the p...">ignoreDataChildren</a>( <span class="keywordtype">bool</span> ignore = <span class="keyword">true</span> ) { <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#adfe08f1f7c5af51863f7503ff6b63df5" title="Sets whether data nodes are created as children, in addition to being available as the value of the p...">setIgnoreDataChildren</a>( ignore ); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00187"></a>00187         
<a name="l00189"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#aa8546dd6718ba690e2813792635f1be9">00189</a>         <span class="keywordtype">bool</span>    <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#aa8546dd6718ba690e2813792635f1be9" title="Returns whether XML comments are parsed or not.">getParseComments</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mParseComments; }
<a name="l00191"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a213adebec9d16d1367636b950cd7850e">00191</a>         <span class="keywordtype">void</span>    <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a213adebec9d16d1367636b950cd7850e" title="Sets whether XML comments are parsed or not.">setParseComments</a>( <span class="keywordtype">bool</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a86015d0dcf27100e9a0b86d74071b9a2" title="Sets whether XML comments are parsed or not.">parseComments</a> = <span class="keyword">true</span> ) { mParseComments = <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a86015d0dcf27100e9a0b86d74071b9a2" title="Sets whether XML comments are parsed or not.">parseComments</a>; }
<a name="l00193"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#aed425565d5a45e5f8c648fbdc157f5d3">00193</a>         <span class="keywordtype">bool</span>    <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#aed425565d5a45e5f8c648fbdc157f5d3" title="Returns whether CDATA blocks are collapsed automatically or not.">getCollapseCData</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mCollapseCData; }
<a name="l00195"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a7e61362a669e1813c6a47e1dba809160">00195</a>         <span class="keywordtype">void</span>    <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a7e61362a669e1813c6a47e1dba809160" title="Sets whether CDATA blocks are collapsed automatically or not.">setCollapseCData</a>( <span class="keywordtype">bool</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a43b0360a96779db5a6bc1442f4913696" title="Sets whether CDATA blocks are collapsed automatically or not.">collapseCData</a> = <span class="keyword">true</span> ) { mCollapseCData = <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#a43b0360a96779db5a6bc1442f4913696" title="Sets whether CDATA blocks are collapsed automatically or not.">collapseCData</a>; }
<a name="l00197"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#ac4d37ceb155ae1548d491723a8d9e102">00197</a>         <span class="keywordtype">bool</span>    <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#ac4d37ceb155ae1548d491723a8d9e102" title="Returns whether data nodes are created as children, in addition to being available as the value of th...">getIgnoreDataChildren</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mIgnoreDataChildren; }
<a name="l00199"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#adfe08f1f7c5af51863f7503ff6b63df5">00199</a>         <span class="keywordtype">void</span>    <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html#adfe08f1f7c5af51863f7503ff6b63df5" title="Sets whether data nodes are created as children, in addition to being available as the value of the p...">setIgnoreDataChildren</a>( <span class="keywordtype">bool</span> ignore = <span class="keyword">true</span> ) { mIgnoreDataChildren = ignore; }
<a name="l00200"></a>00200         
<a name="l00201"></a>00201       <span class="keyword">private</span>:
<a name="l00202"></a>00202         <span class="keywordtype">bool</span>    mParseComments, mCollapseCData, mIgnoreDataChildren;
<a name="l00203"></a>00203     };
<a name="l00204"></a>00204 
<a name="l00206"></a><a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3">00206</a>     <span class="keyword">typedef</span> <span class="keyword">enum</span> { <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3a01e947060288e1a689b1e826fedb4d43">NODE_UNKNOWN</a>, <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3a66b75b28758770b0b204c07f0a58a998">NODE_DOCUMENT</a>, <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3afc25b2be41435376e0aa57bed3066a03">NODE_ELEMENT</a>, <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3a9741e1ef02650327f32b92941568703b">NODE_CDATA</a>, <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3a9161963f1ea5ef47bda99db3b2187c12">NODE_COMMENT</a>, <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3ac0860148f3ea9de5e6d3e2e97479e474">NODE_DATA</a> } <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3" title="Enum listing all types of XML nodes understood by the parser.">NodeType</a>;
<a name="l00207"></a>00207 
<a name="l00209"></a><a class="code" href="classcinder_1_1_xml_tree.html#a01f95ee0830d2654814a95949fe1d1e9">00209</a>     <a class="code" href="classcinder_1_1_xml_tree.html#a01f95ee0830d2654814a95949fe1d1e9" title="Default constructor, creating an empty node.">XmlTree</a>() : mParent( 0 ), mNodeType( <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3afc25b2be41435376e0aa57bed3066a03">NODE_ELEMENT</a> ) {}
<a name="l00210"></a>00210 
<a name="l00212"></a>00212     <a class="code" href="classcinder_1_1_xml_tree.html#a01f95ee0830d2654814a95949fe1d1e9" title="Default constructor, creating an empty node.">XmlTree</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;rhs );
<a name="l00213"></a>00213     <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp; <a class="code" href="classcinder_1_1_xml_tree.html#afd83aaf9ee01beb2a72f84e96aa50fb0">operator=</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;rhs );
<a name="l00214"></a>00214     
<a name="l00217"></a><a class="code" href="classcinder_1_1_xml_tree.html#a90e6e916f4e6abdeb13ab410b51f741c">00217</a>     <span class="keyword">explicit</span> <a class="code" href="classcinder_1_1_xml_tree.html#a90e6e916f4e6abdeb13ab410b51f741c" title="Parses XML contained in dataSource using the options parseOptions. Commonly used with the results of ...">XmlTree</a>( <a class="code" href="namespacecinder.html#abf9b2897625343b11326b9e785d44fc6">DataSourceRef</a> dataSource, <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html" title="Options for XML parsing. Passed to the XmlTree constructor.">ParseOptions</a> parseOptions = <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html" title="Options for XML parsing. Passed to the XmlTree constructor.">ParseOptions</a>() ) {
<a name="l00218"></a>00218         loadFromDataSource( dataSource, <span class="keyword">this</span>, parseOptions );
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220 
<a name="l00222"></a>00222     <span class="keyword">explicit</span> <a class="code" href="classcinder_1_1_xml_tree.html#a01f95ee0830d2654814a95949fe1d1e9" title="Default constructor, creating an empty node.">XmlTree</a>( <span class="keyword">const</span> std::string &amp;xmlString, ParseOptions parseOptions = ParseOptions() );
<a name="l00223"></a>00223 
<a name="l00225"></a><a class="code" href="classcinder_1_1_xml_tree.html#a837e1f7848d7990a8c1cb1f1b9840765">00225</a>     <span class="keyword">explicit</span> <a class="code" href="classcinder_1_1_xml_tree.html#a01f95ee0830d2654814a95949fe1d1e9" title="Default constructor, creating an empty node.">XmlTree</a>( <span class="keyword">const</span> std::string &amp;tag, <span class="keyword">const</span> std::string &amp;value, <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> *parent = 0, <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3" title="Enum listing all types of XML nodes understood by the parser.">NodeType</a> type = <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3afc25b2be41435376e0aa57bed3066a03">NODE_ELEMENT</a> )
<a name="l00226"></a>00226         : mTag( tag ), mValue( value ), mParent( parent ), mNodeType( type )
<a name="l00227"></a>00227     {}
<a name="l00228"></a>00228 
<a name="l00230"></a><a class="code" href="classcinder_1_1_xml_tree.html#a572922d4a13bf6ef8391f2e5f11a9c55">00230</a>     <span class="keyword">static</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>      <a class="code" href="classcinder_1_1_xml_tree.html#a572922d4a13bf6ef8391f2e5f11a9c55" title="Returns an XML document node.">createDoc</a>() { <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree.html#a01f95ee0830d2654814a95949fe1d1e9" title="Default constructor, creating an empty node.">XmlTree</a>( <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, 0, <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3a66b75b28758770b0b204c07f0a58a998">NODE_DOCUMENT</a> ); }
<a name="l00231"></a>00231 
<a name="l00233"></a><a class="code" href="classcinder_1_1_xml_tree.html#a96eb0930ac8e13466ff645c753eb9105">00233</a>     <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3" title="Enum listing all types of XML nodes understood by the parser.">NodeType</a>                    <a class="code" href="classcinder_1_1_xml_tree.html#a96eb0930ac8e13466ff645c753eb9105" title="Returns the type of this node as a NodeType.">getNodeType</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mNodeType; }
<a name="l00235"></a><a class="code" href="classcinder_1_1_xml_tree.html#a47e6dbaa4a27f14bf5be4c2681922026">00235</a>     <span class="keywordtype">void</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a47e6dbaa4a27f14bf5be4c2681922026" title="Sets the type of this node to NodeType type.">setNodeType</a>( <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3" title="Enum listing all types of XML nodes understood by the parser.">NodeType</a> type ) { mNodeType = type; }
<a name="l00237"></a><a class="code" href="classcinder_1_1_xml_tree.html#a0424ce87c797ad3984429605f0ab91fa">00237</a>     <span class="keywordtype">bool</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a0424ce87c797ad3984429605f0ab91fa" title="Returns whether this node is a document node, meaning it is a root node.">isDocument</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mNodeType == <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3a66b75b28758770b0b204c07f0a58a998">NODE_DOCUMENT</a>; }
<a name="l00239"></a><a class="code" href="classcinder_1_1_xml_tree.html#a063712d000ef66f3a56be37b4b9dde39">00239</a>     <span class="keywordtype">bool</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a063712d000ef66f3a56be37b4b9dde39" title="Returns whether this node is an element node.">isElement</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mNodeType == <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3afc25b2be41435376e0aa57bed3066a03">NODE_ELEMENT</a>; }
<a name="l00241"></a><a class="code" href="classcinder_1_1_xml_tree.html#a9b13245525475aff69577c35710aaf25">00241</a>     <span class="keywordtype">bool</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a9b13245525475aff69577c35710aaf25" title="Returns whether this node represents CDATA. Only possible when a document&#39;s ParseOptions disabled col...">isCData</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mNodeType == <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3a9741e1ef02650327f32b92941568703b">NODE_CDATA</a>; }
<a name="l00243"></a><a class="code" href="classcinder_1_1_xml_tree.html#ad429f6fcad3cbf84411f223963afb0b7">00243</a>     <span class="keywordtype">bool</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#ad429f6fcad3cbf84411f223963afb0b7" title="Returns whether this node represents a comment. Only possible when a document&#39;s ParseOptions enabled ...">isComment</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mNodeType == <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3a9161963f1ea5ef47bda99db3b2187c12">NODE_COMMENT</a>; }
<a name="l00244"></a>00244 
<a name="l00246"></a><a class="code" href="classcinder_1_1_xml_tree.html#a045c5762e7c1d007b99994435975f11a">00246</a>     <span class="keyword">const</span> std::string&amp;          <a class="code" href="classcinder_1_1_xml_tree.html#a045c5762e7c1d007b99994435975f11a" title="Returns the tag or name of the node as a string.">getTag</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mTag; }
<a name="l00248"></a><a class="code" href="classcinder_1_1_xml_tree.html#afdb3bf6fa7cf6d66b700ac82c6a6be5d">00248</a>     <span class="keywordtype">void</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#afdb3bf6fa7cf6d66b700ac82c6a6be5d" title="Sets the tag or name of the node to the string tag.">setTag</a>( <span class="keyword">const</span> std::string &amp;tag ) { mTag = tag; }
<a name="l00249"></a>00249     
<a name="l00251"></a><a class="code" href="classcinder_1_1_xml_tree.html#acc7f1501311af5db881eaada1512bb17">00251</a>     std::string                 <a class="code" href="classcinder_1_1_xml_tree.html#acc7f1501311af5db881eaada1512bb17" title="Returns the value of the node as a string.">getValue</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mValue; }
<a name="l00253"></a>00253     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00254"></a><a class="code" href="classcinder_1_1_xml_tree.html#a5ec7740a5357a3e3d2b988b7e4688e26">00254</a>     T                           <a class="code" href="classcinder_1_1_xml_tree.html#a5ec7740a5357a3e3d2b988b7e4688e26" title="Returns the value of the node parsed as a T. Requires T to support the istream&gt;&gt; operator.">getValue</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> boost::lexical_cast&lt;T&gt;( mValue ); }
<a name="l00256"></a>00256     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00257"></a><a class="code" href="classcinder_1_1_xml_tree.html#adc8883b135cd540135fdf2bc64015098">00257</a>     T                           <a class="code" href="classcinder_1_1_xml_tree.html#adc8883b135cd540135fdf2bc64015098" title="Returns the value of the node parsed as a T. If the value is empty or fails to parse defaultValue is ...">getValue</a>( <span class="keyword">const</span> T &amp;defaultValue )<span class="keyword"> const </span>{ <span class="keywordflow">try</span> { <span class="keywordflow">return</span> boost::lexical_cast&lt;T&gt;( mValue ); } <span class="keywordflow">catch</span>( ... ) { <span class="keywordflow">return</span> defaultValue; } }
<a name="l00258"></a>00258 
<a name="l00260"></a><a class="code" href="classcinder_1_1_xml_tree.html#a8ecacf6938bc26056445689eebff10c5">00260</a>     <span class="keywordtype">void</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a8ecacf6938bc26056445689eebff10c5" title="Sets the value of the node to the string value.">setValue</a>( <span class="keyword">const</span> std::string &amp;value ) { mValue = value; }
<a name="l00262"></a>00262     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00263"></a><a class="code" href="classcinder_1_1_xml_tree.html#a7b08aad8b917bfb227bfab429bf851aa">00263</a>     <span class="keywordtype">void</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a7b08aad8b917bfb227bfab429bf851aa" title="Sets the value of the node to value which is converted to a string first. Requires T to support the o...">setValue</a>( <span class="keyword">const</span> T &amp;value ) { mValue = boost::lexical_cast&lt;std::string&gt;( value ); }
<a name="l00264"></a>00264 
<a name="l00266"></a><a class="code" href="classcinder_1_1_xml_tree.html#a82329654b35fb0cc821d39317378656d">00266</a>     <span class="keywordtype">bool</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a82329654b35fb0cc821d39317378656d" title="Returns whether this node has a parent node.">hasParent</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mParent != NULL; }
<a name="l00268"></a><a class="code" href="classcinder_1_1_xml_tree.html#abed9f24668e197147951b22ddf1e91a3">00268</a>     <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;                    <a class="code" href="classcinder_1_1_xml_tree.html#abed9f24668e197147951b22ddf1e91a3" title="Returns a reference to the node which is the parent of this node.">getParent</a>() { <span class="keywordflow">return</span> *mParent; }
<a name="l00270"></a><a class="code" href="classcinder_1_1_xml_tree.html#a4a8fcb3fc5e3d74d42afe225978f71fd">00270</a>     <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;              <a class="code" href="classcinder_1_1_xml_tree.html#a4a8fcb3fc5e3d74d42afe225978f71fd" title="Returns a reference to the node which is the parent of this node.">getParent</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *mParent; }
<a name="l00271"></a>00271     
<a name="l00273"></a><a class="code" href="classcinder_1_1_xml_tree.html#a2bacc49d3fe4a9c8a00c31eece9551ac">00273</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>                        <a class="code" href="classcinder_1_1_xml_tree.html#a2bacc49d3fe4a9c8a00c31eece9551ac" title="Returns the first child that matches relativePath or end() if none matches.">find</a>( <span class="keyword">const</span> std::string &amp;relativePath, <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> ) { <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>( *<span class="keyword">this</span>, relativePath, caseSensitive, separator ); }
<a name="l00275"></a><a class="code" href="classcinder_1_1_xml_tree.html#ae228cdcd69e5200a0a1431e45d24fb14">00275</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>                   <a class="code" href="classcinder_1_1_xml_tree.html#ae228cdcd69e5200a0a1431e45d24fb14" title="Returns the first child that matches relativePath or end() if none matches.">find</a>( <span class="keyword">const</span> std::string &amp;relativePath, <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( *<span class="keyword">this</span>, relativePath, caseSensitive, separator ); }
<a name="l00277"></a>00277     <span class="keywordtype">bool</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#af2e92b166037a51b1513810537cf6331" title="Returns whether at least one child matches relativePath.">hasChild</a>( <span class="keyword">const</span> std::string &amp;relativePath, <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> ) <span class="keyword">const</span>;
<a name="l00278"></a>00278 
<a name="l00280"></a>00280     <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;                    <a class="code" href="classcinder_1_1_xml_tree.html#a0330c31f8c01d342779c0d2f6da26ab5" title="Returns the first child that matches relativePath. Throws ExcChildNotFound if none matches...">getChild</a>( <span class="keyword">const</span> std::string &amp;relativePath, <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> );
<a name="l00282"></a>00282     <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;              <a class="code" href="classcinder_1_1_xml_tree.html#a0330c31f8c01d342779c0d2f6da26ab5" title="Returns the first child that matches relativePath. Throws ExcChildNotFound if none matches...">getChild</a>( <span class="keyword">const</span> std::string &amp;relativePath, <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> ) <span class="keyword">const</span>;
<a name="l00284"></a><a class="code" href="classcinder_1_1_xml_tree.html#abad54f537c54069fd0737b5fe2cfa71e">00284</a>     std::list&lt;XmlTree&gt;&amp;         <a class="code" href="classcinder_1_1_xml_tree.html#abad54f537c54069fd0737b5fe2cfa71e" title="Returns a reference to the node&#39;s list of children nodes.">getChildren</a>() { <span class="keywordflow">return</span> mChildren; }
<a name="l00286"></a><a class="code" href="classcinder_1_1_xml_tree.html#a26368c58d44d3ec72958c3ac94dfb4c2">00286</a>     <span class="keyword">const</span> std::list&lt;XmlTree&gt;&amp;   <a class="code" href="classcinder_1_1_xml_tree.html#a26368c58d44d3ec72958c3ac94dfb4c2" title="Returns a reference to the node&#39;s list of children nodes.">getChildren</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mChildren; }
<a name="l00287"></a>00287 
<a name="l00289"></a><a class="code" href="classcinder_1_1_xml_tree.html#a5c1ba7c42a42fc449c923ecd8e46ad0c">00289</a>     std::list&lt;Attr&gt;&amp;            <a class="code" href="classcinder_1_1_xml_tree.html#a5c1ba7c42a42fc449c923ecd8e46ad0c" title="Returns a reference to the node&#39;s list of attributes.">getAttributes</a>() { <span class="keywordflow">return</span> mAttributes; }
<a name="l00291"></a><a class="code" href="classcinder_1_1_xml_tree.html#ab1b3c1c4e2e2ca68d4061762394a84d4">00291</a>     <span class="keyword">const</span> std::list&lt;Attr&gt;&amp;      <a class="code" href="classcinder_1_1_xml_tree.html#ab1b3c1c4e2e2ca68d4061762394a84d4" title="Returns a reference to the node&#39;s list of attributes.">getAttributes</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mAttributes; }
<a name="l00292"></a>00292 
<a name="l00294"></a>00294     <span class="keyword">const</span> Attr&amp;                 <a class="code" href="classcinder_1_1_xml_tree.html#abf98dd773a4e571a9114cd97b89ab866" title="Returns a reference to the node attribute named attrName. Throws AttrNotFoundExc if no attribute exis...">getAttribute</a>( <span class="keyword">const</span> std::string &amp;attrName ) <span class="keyword">const</span>;
<a name="l00295"></a>00295 
<a name="l00297"></a><a class="code" href="classcinder_1_1_xml_tree.html#a080283243a5c83a3aeccbac7b4e4f5ae">00297</a>     <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html" title="XML attribute.">Attr</a>                  <a class="code" href="classcinder_1_1_xml_tree.html#a080283243a5c83a3aeccbac7b4e4f5ae" title="Returns an Attr accessor. If the attribute does not exists its Attr&#39;s value will be an empty string...">operator[]</a>( <span class="keyword">const</span> std::string &amp;attrName )<span class="keyword"> const </span>{  <span class="keywordflow">if</span>( <a class="code" href="classcinder_1_1_xml_tree.html#a513316a31348c6abe62ea68afe24cd96">hasAttribute</a>( attrName ) ) <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree.html#abf98dd773a4e571a9114cd97b89ab866" title="Returns a reference to the node attribute named attrName. Throws AttrNotFoundExc if no attribute exis...">getAttribute</a>(attrName); <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html" title="XML attribute.">Attr</a>( const_cast&lt;XmlTree*&gt;( <span class="keyword">this</span> ), attrName, <span class="stringliteral">&quot;&quot;</span> ); }
<a name="l00299"></a><a class="code" href="classcinder_1_1_xml_tree.html#ae9ff1eb0563b3841599633902f4cc175">00299</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html" title="XML attribute.">Attr</a>                        <a class="code" href="classcinder_1_1_xml_tree.html#ae9ff1eb0563b3841599633902f4cc175" title="Returns an Attr accessor. If the attribute does not exists its Attr&#39;s value will be an empty string...">operator[]</a>( <span class="keyword">const</span> std::string &amp;attrName ) {  <span class="keywordflow">if</span>( <a class="code" href="classcinder_1_1_xml_tree.html#a513316a31348c6abe62ea68afe24cd96">hasAttribute</a>( attrName ) ) <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree.html#abf98dd773a4e571a9114cd97b89ab866" title="Returns a reference to the node attribute named attrName. Throws AttrNotFoundExc if no attribute exis...">getAttribute</a>(attrName); <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html" title="XML attribute.">Attr</a>( <span class="keyword">this</span>, attrName, <span class="stringliteral">&quot;&quot;</span> ); }
<a name="l00300"></a>00300 
<a name="l00302"></a><a class="code" href="classcinder_1_1_xml_tree.html#ad23ae9f5746fa84bb424e1b642fc8406">00302</a>     <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;              <a class="code" href="classcinder_1_1_xml_tree.html#ad23ae9f5746fa84bb424e1b642fc8406" title="Returns the first child that matches childName. Throws ExcChildNotFound if none matches.">operator/</a>( <span class="keyword">const</span> std::string &amp;childName )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree.html#a0330c31f8c01d342779c0d2f6da26ab5" title="Returns the first child that matches relativePath. Throws ExcChildNotFound if none matches...">getChild</a>( childName ); }
<a name="l00304"></a><a class="code" href="classcinder_1_1_xml_tree.html#acfa3547141c5348f692a13420a9b6f06">00304</a>     <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;                    <a class="code" href="classcinder_1_1_xml_tree.html#acfa3547141c5348f692a13420a9b6f06" title="Returns the first child that matches childName. Throws ExcChildNotFound if none matches.">operator/</a>( <span class="keyword">const</span> std::string &amp;childName ) { <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree.html#a0330c31f8c01d342779c0d2f6da26ab5" title="Returns the first child that matches relativePath. Throws ExcChildNotFound if none matches...">getChild</a>( childName ); }
<a name="l00305"></a>00305 
<a name="l00308"></a>00308     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00309"></a><a class="code" href="classcinder_1_1_xml_tree.html#a2a35e96659494390cc83dda18a280da7">00309</a>     T                           <a class="code" href="classcinder_1_1_xml_tree.html#a2a35e96659494390cc83dda18a280da7" title="Returns the value of the attribute attrName parsed as a T. Throws AttrNotFoundExc if no attribute exi...">getAttributeValue</a>( <span class="keyword">const</span> std::string &amp;attrName )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree.html#abf98dd773a4e571a9114cd97b89ab866" title="Returns a reference to the node attribute named attrName. Throws AttrNotFoundExc if no attribute exis...">getAttribute</a>( attrName ).<a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#ae59186d3bc4c232ee93a477aec64946b" title="Returns the value of the attribute as a string.">getValue</a>&lt;T&gt;(); }
<a name="l00312"></a>00312     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00313"></a><a class="code" href="classcinder_1_1_xml_tree.html#abf1a582f7f3d2d95484af91148594e7f">00313</a>     T                           <a class="code" href="classcinder_1_1_xml_tree.html#abf1a582f7f3d2d95484af91148594e7f" title="Returns the value of the attribute attrName parsed as a T. Returns defaultValue if no attribute exist...">getAttributeValue</a>( <span class="keyword">const</span> std::string &amp;attrName, <span class="keyword">const</span> T &amp;defaultValue )<span class="keyword"> const </span>{
<a name="l00314"></a>00314             <span class="keywordflow">if</span>( <a class="code" href="classcinder_1_1_xml_tree.html#a513316a31348c6abe62ea68afe24cd96">hasAttribute</a>( attrName ) ) {
<a name="l00315"></a>00315                 <span class="keywordflow">try</span> {
<a name="l00316"></a>00316                     <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree.html#abf98dd773a4e571a9114cd97b89ab866" title="Returns a reference to the node attribute named attrName. Throws AttrNotFoundExc if no attribute exis...">getAttribute</a>( attrName ).<a class="code" href="classcinder_1_1_xml_tree_1_1_attr.html#ae59186d3bc4c232ee93a477aec64946b" title="Returns the value of the attribute as a string.">getValue</a>&lt;T&gt;();
<a name="l00317"></a>00317                 }
<a name="l00318"></a>00318                 <span class="keywordflow">catch</span>(...) {
<a name="l00319"></a>00319                     <span class="keywordflow">return</span> defaultValue;
<a name="l00320"></a>00320                 }
<a name="l00321"></a>00321             }
<a name="l00322"></a>00322             <span class="keywordflow">else</span> <span class="keywordflow">return</span> defaultValue;
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324 
<a name="l00326"></a>00326     <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;                    <a class="code" href="classcinder_1_1_xml_tree.html#a83360683794db21d32e54ff36c18ca8b">setAttribute</a>( <span class="keyword">const</span> std::string &amp;attrName, <span class="keyword">const</span> std::string &amp;value );
<a name="l00328"></a>00328     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00329"></a><a class="code" href="classcinder_1_1_xml_tree.html#ad91f3e102894c5eb2092c3518380a016">00329</a>     <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>&amp;                    <a class="code" href="classcinder_1_1_xml_tree.html#ad91f3e102894c5eb2092c3518380a016">setAttribute</a>( <span class="keyword">const</span> std::string &amp;attrName, <span class="keyword">const</span> T &amp;value ) { <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree.html#ad91f3e102894c5eb2092c3518380a016">setAttribute</a>( attrName, boost::lexical_cast&lt;std::string&gt;( value ) ); }
<a name="l00331"></a>00331     <span class="keywordtype">bool</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a513316a31348c6abe62ea68afe24cd96">hasAttribute</a>( <span class="keyword">const</span> std::string &amp;attrName ) <span class="keyword">const</span>;
<a name="l00333"></a>00333     std::string                 <a class="code" href="classcinder_1_1_xml_tree.html#a30b692af881ada011cf94668774ec7a9">getPath</a>( <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> ) <span class="keyword">const</span>;
<a name="l00334"></a>00334     
<a name="l00336"></a><a class="code" href="classcinder_1_1_xml_tree.html#a932a9559ce3cacb3ddaa58f65e268741">00336</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>                        <a class="code" href="classcinder_1_1_xml_tree.html#a932a9559ce3cacb3ddaa58f65e268741">begin</a>() { <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>( &amp;mChildren ); }
<a name="l00338"></a><a class="code" href="classcinder_1_1_xml_tree.html#ab653d685ae80e5b2dc07bd9fea8ea8be">00338</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>                        <a class="code" href="classcinder_1_1_xml_tree.html#ab653d685ae80e5b2dc07bd9fea8ea8be">begin</a>( <span class="keyword">const</span> std::string &amp;filterPath, <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> ) { <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>( *<span class="keyword">this</span>, filterPath, caseSensitive, separator ); }    
<a name="l00340"></a><a class="code" href="classcinder_1_1_xml_tree.html#a5d4c86660311df7521a072cf1a0ca819">00340</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>                   <a class="code" href="classcinder_1_1_xml_tree.html#a5d4c86660311df7521a072cf1a0ca819">begin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( &amp;mChildren ); }
<a name="l00342"></a><a class="code" href="classcinder_1_1_xml_tree.html#ac307060ca81356a4c933cd044f8781b0">00342</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>                   <a class="code" href="classcinder_1_1_xml_tree.html#ac307060ca81356a4c933cd044f8781b0">begin</a>( <span class="keyword">const</span> std::string &amp;filterPath, <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;/&#39;</span> )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( *<span class="keyword">this</span>, filterPath, caseSensitive, separator ); } 
<a name="l00344"></a><a class="code" href="classcinder_1_1_xml_tree.html#a54fb430a869b3fd52454be0299687844">00344</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>                        <a class="code" href="classcinder_1_1_xml_tree.html#a54fb430a869b3fd52454be0299687844">end</a>() { <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_iter.html" title="An iterator over the children of an XmlTree.">Iter</a>( &amp;mChildren, mChildren.end() ); }
<a name="l00346"></a><a class="code" href="classcinder_1_1_xml_tree.html#a816215cf3b78571dbae42f4a615cfc19">00346</a>     <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>                   <a class="code" href="classcinder_1_1_xml_tree.html#a816215cf3b78571dbae42f4a615cfc19">end</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_const_iter.html" title="A const iterator over the children of an XmlTree.">ConstIter</a>( &amp;mChildren, mChildren.end() ); }
<a name="l00348"></a>00348     <span class="keywordtype">void</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a28acc1795c319d4942971831e2bf8909">push_back</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;newChild );
<a name="l00349"></a>00349 
<a name="l00351"></a><a class="code" href="classcinder_1_1_xml_tree.html#a3d19c06be47e41ddc45320d82e8d82b8">00351</a>     std::string                 <a class="code" href="classcinder_1_1_xml_tree.html#a3d19c06be47e41ddc45320d82e8d82b8">getDocType</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mDocType; }
<a name="l00353"></a><a class="code" href="classcinder_1_1_xml_tree.html#aedb4679688440778e82230b06888c60c">00353</a>     <span class="keywordtype">void</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#aedb4679688440778e82230b06888c60c">setDocType</a>( <span class="keyword">const</span> std::string &amp;docType ) { mDocType = docType; }
<a name="l00354"></a>00354 
<a name="l00356"></a>00356     <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classcinder_1_1_xml_tree.html#a0f002c0af29c06e9c69689346afac943">operator&lt;&lt;</a>( std::ostream &amp;out, <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;xml );
<a name="l00358"></a>00358     <span class="keywordtype">void</span>                        <a class="code" href="classcinder_1_1_xml_tree.html#a33392d8f768b5bfc9fa23890ca4deea0">write</a>( <a class="code" href="namespacecinder.html#a7fd1772289ec39e6cef6da865f4c5161">DataTargetRef</a> target, <span class="keywordtype">bool</span> createDocument = <span class="keyword">true</span> );
<a name="l00359"></a>00359 
<a name="l00361"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_exception.html">00361</a>     <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree_1_1_exception.html" title="Base class for XmlTree exceptions.">Exception</a> : <span class="keyword">public</span> <a class="code" href="classcinder_1_1_exception.html">cinder::Exception</a> {
<a name="l00362"></a>00362     };
<a name="l00363"></a>00363     
<a name="l00365"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_exc_child_not_found.html">00365</a>     <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree_1_1_exc_child_not_found.html" title="Exception expressing the absence of an expected child node.">ExcChildNotFound</a> : <span class="keyword">public</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_exception.html" title="Base class for XmlTree exceptions.">XmlTree::Exception</a> {
<a name="l00366"></a>00366       <span class="keyword">public</span>:
<a name="l00367"></a>00367         <a class="code" href="classcinder_1_1_xml_tree_1_1_exc_child_not_found.html#ad5c9334098887461565f2dfe3323ca9e">ExcChildNotFound</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;node, <span class="keyword">const</span> std::string &amp;childPath ) <span class="keywordflow">throw</span>();
<a name="l00368"></a>00368       
<a name="l00369"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_exc_child_not_found.html#a038f7d92583858735a90c780ca67636c">00369</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classcinder_1_1_xml_tree_1_1_exc_child_not_found.html#a038f7d92583858735a90c780ca67636c">what</a>() <span class="keyword">const</span> throw() { <span class="keywordflow">return</span> mMessage; }
<a name="l00370"></a>00370       
<a name="l00371"></a>00371       <span class="keyword">private</span>:
<a name="l00372"></a>00372         <span class="keywordtype">char</span> mMessage[2048];
<a name="l00373"></a>00373     };
<a name="l00374"></a>00374 
<a name="l00376"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_exc_attr_not_found.html">00376</a>     <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree_1_1_exc_attr_not_found.html" title="Exception expressing the absence of an expected attribute.">ExcAttrNotFound</a> : <span class="keyword">public</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_exception.html" title="Base class for XmlTree exceptions.">XmlTree::Exception</a> {
<a name="l00377"></a>00377       <span class="keyword">public</span>:
<a name="l00378"></a>00378         <a class="code" href="classcinder_1_1_xml_tree_1_1_exc_attr_not_found.html#af1da287102d7f4ed8b83ab387c027284">ExcAttrNotFound</a>( <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;node, <span class="keyword">const</span> std::string &amp;attrName ) <span class="keywordflow">throw</span>();
<a name="l00379"></a>00379               
<a name="l00380"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_exc_attr_not_found.html#a1522bbe2006a1e7ef7644eb83c8d7c3a">00380</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classcinder_1_1_xml_tree_1_1_exc_attr_not_found.html#a1522bbe2006a1e7ef7644eb83c8d7c3a">what</a>() <span class="keyword">const</span> throw() { <span class="keywordflow">return</span> mMessage; }
<a name="l00381"></a>00381       
<a name="l00382"></a>00382       <span class="keyword">private</span>:
<a name="l00383"></a>00383         <span class="keywordtype">char</span> mMessage[2048];
<a name="l00384"></a>00384     };
<a name="l00385"></a>00385 
<a name="l00387"></a><a class="code" href="classcinder_1_1_xml_tree_1_1_exc_unknown_node_type.html">00387</a>     <span class="keyword">class </span><a class="code" href="classcinder_1_1_xml_tree_1_1_exc_unknown_node_type.html" title="Exception implying an XML node of an unknown type. Implies a low-level problem communicating with Rap...">ExcUnknownNodeType</a> : <span class="keyword">public</span> <a class="code" href="classcinder_1_1_exception.html">cinder::Exception</a> {
<a name="l00388"></a>00388     };
<a name="l00389"></a>00389 
<a name="l00391"></a>00391     std::shared_ptr&lt;rapidxml::xml_document&lt;char&gt; &gt;  <a class="code" href="classcinder_1_1_xml_tree.html#acb6cfbb1df884505021b32f9b9c66ba1" title="Returns a shared_ptr to a RapidXML xml_document. If createDocument is true then an implicit parent NO...">createRapidXmlDoc</a>( <span class="keywordtype">bool</span> createDocument = <span class="keyword">false</span> ) <span class="keyword">const</span>; 
<a name="l00392"></a>00392 
<a name="l00393"></a>00393   <span class="keyword">private</span>:
<a name="l00394"></a>00394     <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>*    getNodePtr( <span class="keyword">const</span> std::string &amp;relativePath, <span class="keywordtype">bool</span> caseSensitive, <span class="keywordtype">char</span> separator ) <span class="keyword">const</span>;
<a name="l00395"></a>00395     <span class="keywordtype">void</span>        appendRapidXmlNode( rapidxml::xml_document&lt;char&gt; &amp;doc, rapidxml::xml_node&lt;char&gt; *parent ) <span class="keyword">const</span>;
<a name="l00396"></a>00396 
<a name="l00397"></a>00397     <span class="keyword">static</span> std::list&lt;XmlTree&gt;::const_iterator   findNextChildNamed( <span class="keyword">const</span> std::list&lt;XmlTree&gt; &amp;sequence, std::list&lt;XmlTree&gt;::const_iterator firstCandidate, <span class="keyword">const</span> std::string &amp;searchTag, <span class="keywordtype">bool</span> caseSensitive );
<a name="l00398"></a>00398 
<a name="l00399"></a>00399     <a class="code" href="classcinder_1_1_xml_tree.html#a6135324728befd55633fa464dd388cf3" title="Enum listing all types of XML nodes understood by the parser.">NodeType</a>                    mNodeType;
<a name="l00400"></a>00400     std::string                 mTag;
<a name="l00401"></a>00401     std::string                 mValue;
<a name="l00402"></a>00402     std::string                 mDocType; <span class="comment">// only used on NodeType::NODE_DOCUMENT</span>
<a name="l00403"></a>00403     <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a>                     *mParent;
<a name="l00404"></a>00404     std::list&lt;XmlTree&gt;          mChildren;
<a name="l00405"></a>00405     std::list&lt;Attr&gt;         mAttributes;
<a name="l00406"></a>00406     
<a name="l00407"></a>00407     <span class="keyword">static</span> <span class="keywordtype">void</span>     loadFromDataSource( <a class="code" href="namespacecinder.html#abf9b2897625343b11326b9e785d44fc6">DataSourceRef</a> dataSource, <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> *result, <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree_1_1_parse_options.html" title="Options for XML parsing. Passed to the XmlTree constructor.">ParseOptions</a> &amp;parseOptions );
<a name="l00408"></a>00408 };
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 std::ostream&amp; <a class="code" href="namespacecinder.html#a5bcbe587c4e08df583013092cce963f9">operator&lt;&lt;</a>( std::ostream &amp;out, <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">XmlTree</a> &amp;xml );
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 } <span class="comment">// namespace cinder</span>
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="keyword">namespace </span>std {
<a name="l00415"></a>00415 
<a name="l00417"></a>00417 <span class="keyword">template</span>&lt;&gt;
<a name="l00418"></a>00418 <span class="keyword">struct </span>iterator_traits&lt;cinder::XmlTree::Iter&gt; {
<a name="l00419"></a>00419     <span class="keyword">typedef</span> <a class="code" href="classcinder_1_1_xml_tree.html">cinder::XmlTree</a>         value_type;
<a name="l00420"></a>00420     <span class="keyword">typedef</span> ptrdiff_t               difference_type;
<a name="l00421"></a>00421     <span class="keyword">typedef</span> forward_iterator_tag    iterator_category;
<a name="l00422"></a>00422     <span class="keyword">typedef</span> <a class="code" href="classcinder_1_1_xml_tree.html">cinder::XmlTree</a>*        pointer;
<a name="l00423"></a>00423     <span class="keyword">typedef</span> <a class="code" href="classcinder_1_1_xml_tree.html">cinder::XmlTree</a>&amp;        reference;
<a name="l00424"></a>00424 };
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="keyword">template</span>&lt;&gt;
<a name="l00427"></a>00427 <span class="keyword">struct </span>iterator_traits&lt;cinder::XmlTree::ConstIter&gt; {
<a name="l00428"></a>00428     <span class="keyword">typedef</span> <a class="code" href="classcinder_1_1_xml_tree.html">cinder::XmlTree</a>         value_type;
<a name="l00429"></a>00429     <span class="keyword">typedef</span> ptrdiff_t               difference_type;
<a name="l00430"></a>00430     <span class="keyword">typedef</span> forward_iterator_tag    iterator_category;
<a name="l00431"></a>00431     <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">cinder::XmlTree</a>*  pointer;
<a name="l00432"></a>00432     <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="classcinder_1_1_xml_tree.html">cinder::XmlTree</a>&amp;  reference;
<a name="l00433"></a>00433 };
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 } <span class="comment">// namespace std</span>
</pre></div></div><!-- contents -->
	<div class="footer">
		<p> </p>
	</div>
</div>	
</body>
</html>
